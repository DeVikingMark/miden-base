use.$kernel::constants
use.std::mem

# ERRORS
# =================================================================================================

const.ERR_NOTE_NUM_OF_ASSETS_EXCEED_LIMIT="number of assets in a note exceed 255"

const.ERR_ACCOUNT_IS_NOT_NATIVE="the current account is not native"

const.ERR_ACCOUNT_STACK_OVERFLOW="depth of the nested FPI calls exceeded 64"

const.ERR_ACCOUNT_STACK_UNDERFLOW="failed to end foreign context because the current account is the native account"

const.ERR_FOREIGN_ACCOUNT_CONTEXT_AGAINST_NATIVE_ACCOUNT="creation of a foreign context against the native account is forbidden"

const.ERR_LINK_MAP_MAX_ENTRIES_EXCEEDED="number of link map entries exceeds maximum"

# MEMORY ADDRESS CONSTANTS
# =================================================================================================

# BOOK KEEPING
# -------------------------------------------------------------------------------------------------

# The memory address at which a pointer to the currently active input note is stored.
const.ACTIVE_INPUT_NOTE_PTR=0

# The memory address at which the number of output notes is stored.
const.NUM_OUTPUT_NOTES_PTR=4

# The memory address at which the input vault root is stored.
const.INPUT_VAULT_ROOT_PTR=8

# The memory address at which the output vault root is stored.
const.OUTPUT_VAULT_ROOT_PTR=12

# The memory address at which the dirty flag of the storage commitment of the native account is
# stored.
#
# This binary flag specifies whether the commitment is outdated: it holds 1 if some changes were
# made to the account storage since the last re-computation, and 0 otherwise.
const.NATIVE_ACCT_STORAGE_COMMITMENT_DIRTY_FLAG_PTR=16

# The memory address at which the absolute expiration block number is stored.
const.TX_EXPIRATION_BLOCK_NUM_PTR=20

# The memory address at which the pointer to the account stack element containing the pointer to the
# currently accessing account data is stored.
const.ACCOUNT_STACK_TOP_PTR=24

# Pointer to the first element on the account stack.
const.MIN_ACCOUNT_STACK_PTR=25

# Pointer to the last element on the account stack.
const.MAX_ACCOUNT_STACK_PTR=88

# GLOBAL INPUTS
# -------------------------------------------------------------------------------------------------

# The memory address at which the global inputs section begins.
const.GLOBAL_INPUTS_SECTION_OFFSET=400

# The memory address at which the transaction reference block's commitment is stored.
const.BLOCK_COMMITMENT_PTR=400

# The memory address at which the native account ID is stored.
const.NATIVE_ACCT_ID_PTR=404

# The memory address at which the initial account commitment is stored.
const.INIT_ACCOUNT_COMMITMENT_PTR=408

# The memory address at which the initial nonce is stored.
const.INIT_NONCE_PTR=412

# The memory address at which the initial vault root of the native account is stored.
const.INIT_NATIVE_ACCOUNT_VAULT_ROOT_PTR=416

# The memory address at which the initial storage commitment of the native account is stored.
const.INIT_NATIVE_ACCOUNT_STORAGE_COMMITMENT_PTR=420

# The memory address at which the input notes commitment is stored.
const.INPUT_NOTES_COMMITMENT_PTR=424

# The memory address at which the transaction script mast root is stored.
const.TX_SCRIPT_ROOT_PTR=428

# The memory address at which the transaction script arguments are stored.
const.TX_SCRIPT_ARGS_PTR=432

# The memory address at which the auth procedure arguments are stored.
const.AUTH_ARGS_PTR=436

# GLOBAL BLOCK DATA
# -------------------------------------------------------------------------------------------------

# The memory address at which the block data section begins
const.BLOCK_DATA_SECTION_OFFSET=800

# The memory address at which the previous block commitment is stored
const.PREV_BLOCK_COMMITMENT_PTR=800

# The memory address at which the chain commitment is stored
const.CHAIN_COMMITMENT_PTR=804

# The memory address at which the account root is stored
const.ACCT_DB_ROOT_PTR=808

# The memory address at which the nullifier root is stored
const.NULLIFIER_ROOT_PTR=812

# The memory address at which the tx commitment is stored
const.TX_COMMITMENT_PTR=816

# The memory address at which the kernel commitment is stored
const.TX_KERNEL_COMMITMENT_PTR=820

# The memory address at which the proof commitment is stored
const.PROOF_COMMITMENT_PTR=824

# The memory address at which the block metadata is stored [block_number, version, timestamp, 0]
const.BLOCK_METADATA_PTR=828

# The memory address at which the fee parameters are stored. These occupy a double word.
# [native_asset_id_suffix, native_asset_id_prefix, verification_base_fee, 0]
# [0, 0, 0, 0]
const.FEE_PARAMETERS_PTR=832

# The memory address at which the verification base fee is stored.
const.VERIFICATION_BASE_FEE_PTR=FEE_PARAMETERS_PTR+2

# The memory address at which the note root is stored
const.NOTE_ROOT_PTR=840

# PARTIAL BLOCKCHAIN
# -------------------------------------------------------------------------------------------------

# The memory address at which the chain data section begins
const.PARTIAL_BLOCKCHAIN_PTR=1200

# The memory address at which the total number of leaves in the partial blockchain is stored
const.PARTIAL_BLOCKCHAIN_NUM_LEAVES_PTR=1200

# The memory address at which the partial blockchain peaks are stored
const.PARTIAL_BLOCKCHAIN_PEAKS_PTR=1204

# KERNEL DATA
# -------------------------------------------------------------------------------------------------

# The memory address at which the number of the kernel procedures is stored.
const.NUM_KERNEL_PROCEDURES_PTR=1600

# The memory address at which the hashes of kernel procedures begin.
const.KERNEL_PROCEDURES_PTR=1604

# ACCOUNT DATA
# -------------------------------------------------------------------------------------------------

# The largest memory address which can be used to load the foreign account data.
# It is computed as `2048 * 64 * 4` -- this is the memory address where the data block of the 64th
# account starts.
const.MAX_FOREIGN_ACCOUNT_PTR=524288

# The memory address at which the native account data is stored.
const.NATIVE_ACCOUNT_DATA_PTR=8192

# The length of the memory interval that the account data occupies.
const.ACCOUNT_DATA_LENGTH=8192

# The offsets at which the account data is stored relative to the start of the account data segment.
const.ACCT_ID_AND_NONCE_OFFSET=0
const.ACCT_NONCE_OFFSET=3
const.ACCT_VAULT_ROOT_OFFSET=4
const.ACCT_STORAGE_COMMITMENT_OFFSET=8
const.ACCT_CODE_COMMITMENT_OFFSET=12
const.ACCT_CORE_DATA_SECTION_END_OFFSET=16
const.NUM_ACCT_PROCEDURES_OFFSET=28
const.ACCT_PROCEDURES_SECTION_OFFSET=32
const.ACCT_PROCEDURES_CALL_TRACKING_OFFSET=2084
const.NUM_ACCT_STORAGE_SLOTS_OFFSET=2340
const.ACCT_STORAGE_SLOTS_SECTION_OFFSET=2344

# Offset at which an exact copy of the account's storage slot section starting at
# ACCT_STORAGE_SLOTS_SECTION_OFFSET is kept. This keeps the initial values of the account storage
# slots accessible to enable computing a diff between the initial and current account storage slots
# for use in the account delta. This section is only present for the native account.
const.ACCT_INITIAL_STORAGE_SLOTS_SECTION_OFFSET=4384

# NATIVE ACCOUNT DELTA
# -------------------------------------------------------------------------------------------------

# The link map pointer at which the delta of the fungible asset vault is stored.
const.ACCOUNT_DELTA_FUNGIBLE_ASSET_PTR=532480

# The link map pointer at which the delta of the non-fungible asset vault is stored.
const.ACCOUNT_DELTA_NON_FUNGIBLE_ASSET_PTR=ACCOUNT_DELTA_FUNGIBLE_ASSET_PTR+4

# The section of link map pointers where storage map deltas are stored.
# This section is offset by `slot index` to get the link map ptr for the storage map
# delta at that slot index. Slot indices that are not map slots are simply unused.
const.ACCOUNT_DELTA_STORAGE_MAP_SECTION=ACCOUNT_DELTA_FUNGIBLE_ASSET_PTR+8

# INPUT NOTES DATA
# -------------------------------------------------------------------------------------------------

# The memory address at which the input note section begins.
const.INPUT_NOTE_SECTION_OFFSET=4194304

# The memory address at which the nullifier section of the input notes begins.
const.INPUT_NOTE_NULLIFIER_SECTION_PTR=4194308

# The memory address at which the input note data section begins.
const.INPUT_NOTE_DATA_SECTION_OFFSET=4259840

# The memory address at which the number of input notes is stored.
const.NUM_INPUT_NOTES_PTR=INPUT_NOTE_SECTION_OFFSET

# The offsets at which data of an input note is stored relative to the start of its data segment
const.INPUT_NOTE_ID_OFFSET=0
const.INPUT_NOTE_CORE_DATA_OFFSET=4
const.INPUT_NOTE_SERIAL_NUM_OFFSET=4
const.INPUT_NOTE_SCRIPT_ROOT_OFFSET=8
const.INPUT_NOTE_INPUTS_COMMITMENT_OFFSET=12
const.INPUT_NOTE_ASSETS_COMMITMENT_OFFSET=16
const.INPUT_NOTE_RECIPIENT_OFFSET=20
const.INPUT_NOTE_METADATA_OFFSET=24
const.INPUT_NOTE_ARGS_OFFSET=28
const.INPUT_NOTE_NUM_INPUTS_OFFSET=32
const.INPUT_NOTE_NUM_ASSETS_OFFSET=36
const.INPUT_NOTE_ASSETS_OFFSET=40

# OUTPUT NOTES
# -------------------------------------------------------------------------------------------------

# The memory address at which the output notes section begins.
const.OUTPUT_NOTE_SECTION_OFFSET=16777216

# The offsets at which data of an output note is stored relative to the start of its data segment.
const.OUTPUT_NOTE_ID_OFFSET=0
const.OUTPUT_NOTE_METADATA_OFFSET=4
const.OUTPUT_NOTE_RECIPIENT_OFFSET=8
const.OUTPUT_NOTE_ASSETS_COMMITMENT_OFFSET=12
const.OUTPUT_NOTE_NUM_ASSETS_OFFSET=16
const.OUTPUT_NOTE_DIRTY_FLAG_OFFSET=17
const.OUTPUT_NOTE_ASSETS_OFFSET=20

# LINK MAP MEMORY
# -------------------------------------------------------------------------------------------------

# The inclusive start of the link map dynamic memory region.
# Chosen as a number greater than 2^25 such that all entry pointers are multiples of
# LINK_MAP_ENTRY_SIZE. That enables a simpler check in assert_entry_ptr_is_valid.
const.LINK_MAP_REGION_START_PTR=33554448

# The non-inclusive end of the link map dynamic memory region.
# This happens to be 2^26, but if it is changed, it should be chosen as a number such that
# LINK_MAP_REGION_END_PTR - LINK_MAP_REGION_START_PTR is a multiple of LINK_MAP_ENTRY_SIZE,
# because that enables checking whether a newly allocated entry pointer is at the end of the range
# using equality rather than lt/gt in link_map_malloc.
const.LINK_MAP_REGION_END_PTR=67108864

# LINK_MAP_REGION_START_PTR + the currently used size stored at this pointer defines the next
# entry pointer that will be allocated.
const.LINK_MAP_USED_MEMORY_SIZE=33554432

# The size of each map entry, i.e. four words.
const.LINK_MAP_ENTRY_SIZE=16

# MEMORY PROCEDURES
# =================================================================================================

# BOOK KEEPING
# -------------------------------------------------------------------------------------------------

#! Returns the current number of output notes created in this transaction.
#!
#! Inputs:  []
#! Outputs: [num_output_notes]
#!
#! Where:
#! - num_output_notes is the number of output notes created in this transaction so far.
export.get_num_output_notes
    mem_load.NUM_OUTPUT_NOTES_PTR
end

#! Sets the number of output notes.
#!
#! Inputs:  [num_output_notes]
#! Outputs: []
#!
#! Where:
#! - num_output_notes is the number of output notes.
export.set_num_output_notes
    mem_store.NUM_OUTPUT_NOTES_PTR
end

#! Returns the pointer to the active input note.
#!
#! Inputs:  []
#! Outputs: [note_ptr]
#!
#! Where:
#! - note_ptr is the memory address of the data segment for the active note.
export.get_active_input_note_ptr
    mem_load.ACTIVE_INPUT_NOTE_PTR
end

#! Sets the active note pointer to the specified value.
#!
#! Inputs:  [note_ptr]
#! Outputs: []
#!
#! Where:
#! - note_ptr is the new memory address of the data segment for the input note.
export.set_active_input_note_ptr
    mem_store.ACTIVE_INPUT_NOTE_PTR
end

#! Returns the pointer to the memory address at which the input vault root is stored.
#!
#! Inputs:  []
#! Outputs: [input_vault_root_ptr]
#!
#! Where:
#! - input_vault_root_ptr is a pointer to the memory address at which the input vault root is
#!   stored.
export.get_input_vault_root_ptr
    push.INPUT_VAULT_ROOT_PTR
end

#! Returns the input vault root.
#!
#! Inputs:  []
#! Outputs: [INPUT_VAULT_ROOT]
#!
#! Where:
#! - INPUT_VAULT_ROOT is the input vault root.
export.get_input_vault_root
    padw mem_loadw.INPUT_VAULT_ROOT_PTR
end

#! Sets the input vault root.
#!
#! Inputs:  [INPUT_VAULT_ROOT]
#! Outputs: [INPUT_VAULT_ROOT]
#!
#! Where:
#! - INPUT_VAULT_ROOT is the input vault root.
export.set_input_vault_root
    mem_storew.INPUT_VAULT_ROOT_PTR
end

#! Returns the pointer to the memory address at which the output vault root is stored.
#!
#! Inputs:  []
#! Outputs: [output_vault_root_ptr]
#!
#! Where:
#! - output_vault_root_ptr is the pointer to the memory address at which the output vault root is
#!   stored.
export.get_output_vault_root_ptr
    push.OUTPUT_VAULT_ROOT_PTR
end

#! Returns the output vault root.
#!
#! Inputs:  []
#! Outputs: [OUTPUT_VAULT_ROOT]
#!
#! Where:
#! - OUTPUT_VAULT_ROOT is the output vault root.
export.get_output_vault_root
    padw mem_loadw.OUTPUT_VAULT_ROOT_PTR
end

#! Sets the output vault root.
#!
#! Inputs:  [OUTPUT_VAULT_ROOT]
#! Outputs: [OUTPUT_VAULT_ROOT]
#!
#! Where:
#! - OUTPUT_VAULT_ROOT is the output vault root.
export.set_output_vault_root
    mem_storew.OUTPUT_VAULT_ROOT_PTR
end

# GLOBAL INPUTS
# -------------------------------------------------------------------------------------------------

#! Sets the commitment of the transaction reference block.
#!
#! Inputs:  [BLOCK_COMMITMENT]
#! Outputs: [BLOCK_COMMITMENT]
#!
#! Where:
#! - BLOCK_COMMITMENT is the commitment of the transaction reference block.
export.set_block_commitment
    mem_storew.BLOCK_COMMITMENT_PTR
end

#! Returns the block commitment of the reference block.
#!
#! Inputs:  []
#! Outputs: [BLOCK_COMMITMENT]
#!
#! Where:
#! - BLOCK_COMMITMENT is the commitment of the transaction reference block.
export.get_block_commitment
    padw mem_loadw.BLOCK_COMMITMENT_PTR
end

#! Sets the ID of the native account.
#!
#! Inputs:  [account_id_prefix, account_id_suffix]
#! Outputs: []
#!
#! Where:
#! - account_id_{prefix,suffix} are the prefix and suffix felts of the account ID.
export.set_global_account_id
    push.0.0
    # => [0, 0, account_id_prefix, account_id_suffix]
    mem_storew.NATIVE_ACCT_ID_PTR
    dropw
    # => []
end

#! Returns the ID of the native account.
#!
#! Inputs:  []
#! Outputs: [account_id_prefix, account_id_suffix]
#!
#! Where:
#! - account_id_{prefix,suffix} are the prefix and suffix felts of the account ID.
export.get_global_account_id
    padw mem_loadw.NATIVE_ACCT_ID_PTR
    # => [0, 0, account_id_prefix, account_id_suffix]
    drop drop
end

#! Sets the native account commitment at the beginning of the transaction.
#!
#! Inputs:  [INIT_ACCOUNT_COMMITMENT]
#! Outputs: [INIT_ACCOUNT_COMMITMENT]
#!
#! Where:
#! - INIT_ACCOUNT_COMMITMENT is the initial account commitment.
export.set_init_account_commitment
    mem_storew.INIT_ACCOUNT_COMMITMENT_PTR
end

#! Returns the native account commitment at the beginning of the transaction.
#!
#! Inputs:  []
#! Outputs: [INIT_ACCOUNT_COMMITMENT]
#!
#! Where:
#! - INIT_ACCOUNT_COMMITMENT is the initial account commitment.
export.get_init_account_commitment
    padw mem_loadw.INIT_ACCOUNT_COMMITMENT_PTR
end

#! Sets the initial account nonce.
#!
#! Inputs:  [init_nonce]
#! Outputs: []
#!
#! Where:
#! - init_nonce is the initial account nonce.
export.set_init_nonce
    mem_store.INIT_NONCE_PTR
end

#! Returns the initial account nonce.
#!
#! Inputs:  []
#! Outputs: [init_nonce]
#!
#! Where:
#! - init_nonce is the initial account nonce.
export.get_init_nonce
    mem_load.INIT_NONCE_PTR
end

#! Sets the vault root of the native account at the beginning of the transaction.
#!
#! Inputs:  [INIT_NATIVE_ACCOUNT_VAULT_ROOT]
#! Outputs: [INIT_NATIVE_ACCOUNT_VAULT_ROOT]
#!
#! Where:
#! - INIT_NATIVE_ACCOUNT_VAULT_ROOT is the initial vault root of the native account.
export.set_init_native_account_vault_root
    mem_storew.INIT_NATIVE_ACCOUNT_VAULT_ROOT_PTR
end

#! Returns the vault root of the native account at the beginning of the transaction.
#!
#! Inputs:  []
#! Outputs: [INIT_NATIVE_ACCOUNT_VAULT_ROOT]
#!
#! Where:
#! - INIT_NATIVE_ACCOUNT_VAULT_ROOT is the initial vault root of the native account.
export.get_init_native_account_vault_root
    padw mem_loadw.INIT_NATIVE_ACCOUNT_VAULT_ROOT_PTR
end

#! Returns the memory address of the vault root of the native account at the beginning of the 
#! transaction.
#!
#! Inputs:  []
#! Outputs: [native_account_initial_vault_root_ptr]
#!
#! Where:
#! - native_account_initial_vault_root_ptr is the memory pointer to the initial vault root of the 
#!   native account.
export.get_init_native_account_vault_root_ptr
    push.INIT_NATIVE_ACCOUNT_VAULT_ROOT_PTR
end

#! Sets the storage commitment of the native account at the beginning of the transaction.
#!
#! Inputs:  [INIT_NATIVE_ACCOUNT_STORAGE_COMMITMENT]
#! Outputs: [INIT_NATIVE_ACCOUNT_STORAGE_COMMITMENT]
#!
#! Where:
#! - INIT_NATIVE_ACCOUNT_STORAGE_COMMITMENT is the initial storage commitment of the native account.
export.set_init_account_storage_commitment
    mem_storew.INIT_NATIVE_ACCOUNT_STORAGE_COMMITMENT_PTR
end

#! Returns the storage commitment of the native account at the beginning of the transaction.
#!
#! Inputs:  []
#! Outputs: [INIT_NATIVE_ACCOUNT_STORAGE_COMMITMENT]
#!
#! Where:
#! - INIT_NATIVE_ACCOUNT_STORAGE_COMMITMENT is the initial storage commitment of the native account.
export.get_init_account_storage_commitment
    padw mem_loadw.INIT_NATIVE_ACCOUNT_STORAGE_COMMITMENT_PTR
end

#! Returns the input notes commitment.
#!
#! See `transaction::api::get_input_notes_commitment` for details.
#!
#! Inputs:  []
#! Outputs: [INPUT_NOTES_COMMITMENT]
#!
#! Where:
#! - INPUT_NOTES_COMMITMENT is the input notes commitment.
export.get_input_notes_commitment
    padw mem_loadw.INPUT_NOTES_COMMITMENT_PTR
end

#! Sets the input notes' commitment.
#!
#! Inputs:  [INPUT_NOTES_COMMITMENT]
#! Outputs: [INPUT_NOTES_COMMITMENT]
#!
#! Where:
#! - INPUT_NOTES_COMMITMENT is the notes' commitment.
export.set_nullifier_commitment
    mem_storew.INPUT_NOTES_COMMITMENT_PTR
end

#! Returns the memory address of the transaction script root.
#!
#! Inputs:  []
#! Outputs: [tx_script_root_ptr]
#!
#! Where:
#! - tx_script_root_ptr is the pointer to the memory where transaction script root is stored.
export.get_tx_script_root_ptr
    push.TX_SCRIPT_ROOT_PTR
end

#! Sets the transaction script root.
#!
#! Inputs:  [TX_SCRIPT_ROOT]
#! Outputs: [TX_SCRIPT_ROOT]
#!
#! Where:
#! - TX_SCRIPT_ROOT is the transaction script root.
export.set_tx_script_root
    mem_storew.TX_SCRIPT_ROOT_PTR
end

#! Returns the transaction script arguments.
#!
#! Inputs:  []
#! Outputs: [TX_SCRIPT_ARGS]
#!
#! Where:
#! - TX_SCRIPT_ARGS is the word of values which could be used directly or could be used to obtain
#!   some values associated with it from the advice map.
export.get_tx_script_args
    padw mem_loadw.TX_SCRIPT_ARGS_PTR
end

#! Sets the transaction script arguments.
#!
#! Inputs:  [TX_SCRIPT_ARGS]
#! Outputs: [TX_SCRIPT_ARGS]
#!
#! Where:
#! - TX_SCRIPT_ARGS is the word of values which could be used directly or could be used to obtain
#!   some values associated with it from the advice map.
export.set_tx_script_args
    mem_storew.TX_SCRIPT_ARGS_PTR
end

#! Returns the auth procedure arguments.
#!
#! Inputs:  []
#! Outputs: [AUTH_ARGS]
#!
#! Where:
#! - AUTH_ARGS is the argument passed to the auth procedure.
export.get_auth_args
    padw mem_loadw.AUTH_ARGS_PTR
end

#! Sets the auth procedure arguments.
#!
#! Inputs:  [AUTH_ARGS]
#! Outputs: [AUTH_ARGS]
#!
#! Where:
#! - AUTH_ARGS is the argument passed to the auth procedure.
export.set_auth_args
    mem_storew.AUTH_ARGS_PTR
end

# BLOCK DATA
# -------------------------------------------------------------------------------------------------

#! Returns a pointer to the block data section.
#!
#! Inputs:  []
#! Outputs: [ptr]
#!
#! Where:
#! - ptr is a pointer to the block data section.
export.get_block_data_ptr
    push.BLOCK_DATA_SECTION_OFFSET
end

#! Returns the previous block commitment of the transaction reference block.
#!
#! Inputs:  []
#! Outputs: [PREV_BLOCK_COMMITMENT]
#!
#! Where:
#! - PREV_BLOCK_COMMITMENT_PTR is the block commitment of the transaction reference block.
export.get_prev_block_commitment
    padw mem_loadw.PREV_BLOCK_COMMITMENT_PTR
end

#! Returns the block number of the transaction reference block.
#!
#! Inputs:  []
#! Outputs: [blk_num]
#!
#! Where:
#! - blk_num is the block number of the transaction reference block.
export.get_blk_num
    mem_load.BLOCK_METADATA_PTR
end

#! Returns the protocol version of the transaction reference block.
#!
#! Inputs:  []
#! Outputs: [version]
#!
#! Where:
#! - version is the protocol version of the transaction reference block.
const.BLOCK_METADATA_VERSION_PTR=BLOCK_METADATA_PTR+1
export.get_blk_version
    mem_load.BLOCK_METADATA_VERSION_PTR
end

#! Returns the block timestamp of the reference block for this transaction.
#!
#! Inputs:  []
#! Outputs: [timestamp]
#!
#! Where:
#! - timestamp is the timestamp of the reference block for this transaction.
const.BLOCK_METADATA_TIMESTAMP_PTR=BLOCK_METADATA_PTR+2
export.get_blk_timestamp
    mem_load.BLOCK_METADATA_TIMESTAMP_PTR
end

#! Returns the faucet ID of the native asset as defined in the transaction's reference block.
#!
#! Inputs:  []
#! Outputs: [native_asset_id_prefix, native_asset_id_suffix]
#!
#! Where:
#! - native_asset_id_{prefix,suffix} are the prefix and suffix felts of the faucet ID that defines
#!   the native asset.
export.get_native_asset_id
    padw mem_loadw.FEE_PARAMETERS_PTR drop drop
    # => [native_asset_id_prefix, native_asset_id_suffix]
end

#! Returns the verification base fee from the transaction's reference block.
#!
#! Inputs:  []
#! Outputs: [verification_base_fee]
#!
#! Where:
#! - verification_base_fee is the base fee capturing the cost for the verification of a
#!   transaction.
export.get_verification_base_fee
    mem_load.VERIFICATION_BASE_FEE_PTR
end

#! Returns the chain commitment of the transaction reference block.
#!
#! Inputs:  []
#! Outputs: [CHAIN_COMMITMENT]
#!
#! Where:
#! - CHAIN_COMMITMENT is the chain commitment of the transaction reference block.
export.get_chain_commitment
    padw mem_loadw.CHAIN_COMMITMENT_PTR
end

#! Returns the account db root of the transaction reference block.
#!
#! Inputs:  []
#! Outputs: [ACCT_DB_ROOT]
#!
#! Where:
#! - ACCT_DB_ROOT is the account database root of the transaction reference block.
export.get_account_db_root
    padw mem_loadw.ACCT_DB_ROOT_PTR
end

#! Returns the nullifier db root of the transaction reference block.
#!
#! Inputs:  []
#! Outputs: [NULLIFIER_ROOT]
#!
#! Where:
#! - NULLIFIER_ROOT is the nullifier root of the transaction reference block.
export.get_nullifier_db_root
    padw mem_loadw.NULLIFIER_ROOT_PTR
end

#! Returns the tx commitment of the transaction reference block.
#!
#! Inputs:  []
#! Outputs: [TX_COMMITMENT]
#!
#! Where:
#! - TX_COMMITMENT is the tx commitment of the transaction reference block.
export.get_tx_commitment
    padw mem_loadw.TX_COMMITMENT_PTR
end

#! Returns the transaction kernel commitment of the transaction reference block.
#!
#! Inputs:  []
#! Outputs: [TX_KERNEL_COMMITMENT]
#!
#! Where:
#! - TX_KERNEL_COMMITMENT is the sequential hash of the kernel procedures.
export.get_tx_kernel_commitment
    padw mem_loadw.TX_KERNEL_COMMITMENT_PTR
end

#! Returns the proof commitment of the transaction reference block.
#!
#! Inputs:  []
#! Outputs: [PROOF_COMMITMENT]
#!
#! Where:
#! - PROOF_COMMITMENT is the proof commitment of the transaction reference block.
export.get_proof_commitment
    padw mem_loadw.PROOF_COMMITMENT_PTR
end

#! Returns the note root of the transaction reference block.
#!
#! Inputs:  []
#! Outputs: [NOTE_ROOT]
#!
#! Where:
#! - NOTE_ROOT is the note root of the transaction reference block.
export.get_note_root
    padw mem_loadw.NOTE_ROOT_PTR
end

#! Sets the note root of the transaction reference block.
#!
#! Inputs:  [NOTE_ROOT]
#! Outputs: [NOTE_ROOT]
#!
#! Where:
#! - NOTE_ROOT is the note root of the transaction reference block.
export.set_note_root
    mem_storew.NOTE_ROOT_PTR
end

# CHAIN DATA
# -------------------------------------------------------------------------------------------------

#! Returns a pointer to the partial blockchain section.
#!
#! Inputs:  []
#! Outputs: [ptr]
#!
#! Where:
#! - ptr is the pointer to the partial blockchain section.
export.get_partial_blockchain_ptr
    push.PARTIAL_BLOCKCHAIN_PTR
end

#! Sets the number of leaves in the partial blockchain.
#!
#! Inputs:  [num_leaves]
#! Outputs: []
#!
#! Where:
#! - num_leaves is the number of leaves in the partial blockchain.
export.set_partial_blockchain_num_leaves
    mem_store.PARTIAL_BLOCKCHAIN_NUM_LEAVES_PTR
end

#! Returns a pointer to start of the partial blockchain peaks section.
#!
#! Inputs:  []
#! Outputs: [ptr]
#!
#! Where:
#! - ptr is the pointer to the start of the partial blockchain peaks section.
export.get_partial_blockchain_peaks_ptr
    push.PARTIAL_BLOCKCHAIN_PEAKS_PTR
end

# ACCOUNT DATA
# -------------------------------------------------------------------------------------------------

#! Returns the memory pointer at which the native account data is stored.
#!
#! Inputs:  []
#! Outputs: [ptr]
#!
#! Where:
#! - ptr is the memory address at which the native account data is stored.
export.get_native_account_data_ptr
    push.NATIVE_ACCOUNT_DATA_PTR
end

#! Returns the length of the memory interval that the account data occupies.
#!
#! Inputs:  []
#! Outputs: [account_data_length]
#!
#! Where:
#! - account_data_length is the length of the memory interval that the account data occupies.
export.get_account_data_length
    push.ACCOUNT_DATA_LENGTH
end

#! Returns the largest memory address which can be used to load the foreign account data.
#!
#! Inputs:  []
#! Outputs: [max_foreign_account_ptr]
#!
#! Where:
#! - max_foreign_account_ptr is the largest memory address which can be used to load the foreign
#!   account data.
export.get_max_foreign_account_ptr
    push.MAX_FOREIGN_ACCOUNT_PTR
end

#! Sets the memory pointer of the current account data to the native account (8192).
#!
#! Inputs:  []
#! Outputs: []
export.set_current_account_data_ptr_to_native_account
    # store the native account data pointer into the first account stack element.
    push.NATIVE_ACCOUNT_DATA_PTR mem_store.MIN_ACCOUNT_STACK_PTR
    # => [native_acct_stack_ptr, account_stack_top_ptr]

    # store the pointer to the first account stack element into the account stack top pointer.
    push.MIN_ACCOUNT_STACK_PTR mem_store.ACCOUNT_STACK_TOP_PTR
    # => []
end

#! Returns the memory pointer of the current account data.
#!
#! Inputs:  []
#! Outputs: [ptr]
#!
#! Where:
#! - ptr is the memory address at which the data of the currently used account begins.
export.get_current_account_data_ptr
    mem_load.ACCOUNT_STACK_TOP_PTR
    # => [account_stack_top_ptr]

    mem_load
    # => [current_account_data_ptr]
end

#! Adds the pointer to the account stack.
#!
#! It is done by writing the pointer to the element next to the stack top and moving the top pointer
#! to it.
#!
#! Inputs:  [curr_account_data_ptr]
#! Outputs: []
#!
#! Where:
#! - curr_account_data_ptr is the memory address
#!
#! Panics if:
#! - the account stack is full, containing 64 accounts total.
#! - the provided account data pointer is equal to the native account data pointer.
export.push_ptr_to_account_stack
    # check that the account stack is not full
    mem_load.ACCOUNT_STACK_TOP_PTR dup
    # => [account_stack_top_ptr, account_stack_top_ptr, curr_account_data_ptr]

    u32lt.MAX_ACCOUNT_STACK_PTR assert.err=ERR_ACCOUNT_STACK_OVERFLOW
    # => [account_stack_top_ptr, curr_account_data_ptr]

    # check that the current account data pointer is not equal to the native account data pointer
    dup.1 eq.NATIVE_ACCOUNT_DATA_PTR
    assertz.err=ERR_FOREIGN_ACCOUNT_CONTEXT_AGAINST_NATIVE_ACCOUNT
    # => [account_stack_top_ptr, curr_account_data_ptr]

    add.1 dup movdn.2 mem_store
    # => [account_stack_top_ptr+1]

    mem_store.ACCOUNT_STACK_TOP_PTR
    # => []
end

#! Removes the pointer from the account stack.
#!
#! It is done simply by moving the stack top pointer one element back.
#!
#! Inputs:  []
#! Outputs: []
#!
#! Panics if:
#! - the account stack contains only native account.
export.pop_ptr_from_account_stack
    # check that the account stack always is at least of size 1, that is, it contains at least the
    # native account
    mem_load.ACCOUNT_STACK_TOP_PTR dup
    # => [account_stack_top_ptr, account_stack_top_ptr]

    u32gt.MIN_ACCOUNT_STACK_PTR assert.err=ERR_ACCOUNT_STACK_UNDERFLOW
    # => [account_stack_top_ptr]

    # move the account stack pointer one element back and store it as the top pointer
    sub.1 mem_store.ACCOUNT_STACK_TOP_PTR
    # => []
end

#! Asserts that current account data pointer matches the data pointer of the native account (8192).
#! It is used to prevent usage of the account procedures which can mutate the account state with the
#! foreign accounts.
#!
#! Inputs:  []
#! Outputs: []
#!
#! Panics if:
#! - the current account data pointer is not equal to native account data pointer (8192).
export.assert_native_account
    exec.is_native_account assert.err=ERR_ACCOUNT_IS_NOT_NATIVE
end

#! Returns 1 if the current account data pointer matches the data pointer of the native account,
#! 0 otherwise.
#!
#! Inputs:  []
#! Outputs: [is_native_account]
export.is_native_account
    exec.get_current_account_data_ptr
    # => [current_account_data_ptr]

    eq.NATIVE_ACCOUNT_DATA_PTR
    # => [is_native_account]
end

#! Returns a pointer to the end of the core account data section.
#!
#! Inputs:  []
#! Outputs: [ptr]
#!
#! Where:
#! - ptr is the memory address at which the core account data ends.
export.get_core_account_data_end_ptr
    exec.get_current_account_data_ptr add.ACCT_CORE_DATA_SECTION_END_OFFSET
end

### ACCOUNT ID AND NONCE #################################################

#! Returns the ID of the current account.
#!
#! Inputs:  []
#! Outputs: [account_id_prefix, account_id_suffix]
#!
#! Where:
#! - account_id_{prefix,suffix} are the prefix and suffix felts of the account ID of the currently
#!   accessing account.
export.get_account_id
    padw exec.get_current_account_data_ptr add.ACCT_ID_AND_NONCE_OFFSET mem_loadw
    # => [nonce, 0, account_id_prefix, account_id_suffix]
    drop drop
    # => [account_id_prefix, account_id_suffix]
end

#! Returns the ID of the native account of the transaction.
#!
#! Inputs:  []
#! Outputs: [account_id_prefix, account_id_suffix]
#!
#! Where:
#! - account_id_{prefix,suffix} are the prefix and suffix felts of the ID of the native account
#!   of the transaction.
export.get_native_account_id
    padw push.NATIVE_ACCOUNT_DATA_PTR add.ACCT_ID_AND_NONCE_OFFSET mem_loadw
    # => [nonce, 0, account_id_prefix, account_id_suffix]
    drop drop
    # => [account_id_prefix, account_id_suffix]
end

#! Sets the account ID and nonce.
#!
#! Inputs:  [nonce, 0, account_id_prefix, account_id_suffix]
#! Outputs: [nonce, 0, account_id_prefix, account_id_suffix]
#!
#! Where:
#! - account_id_{prefix,suffix} are the prefix and suffix felts of the ID of the currently accessing
#!   account.
#! - nonce is the nonce of the currently accessing account.
export.set_account_id_and_nonce
    exec.get_current_account_data_ptr add.ACCT_ID_AND_NONCE_OFFSET
    mem_storew
end

#! Returns the nonce of the current account.
#!
#! Inputs:  []
#! Outputs: [nonce]
#!
#! Where:
#! - nonce is the nonce of the current account.
export.get_account_nonce
    exec.get_current_account_data_ptr add.ACCT_NONCE_OFFSET
    mem_load
end

#! Returns the nonce of the native account of the transaction.
#!
#! Inputs:  []
#! Outputs: [nonce]
#!
#! Where:
#! - nonce is the nonce of the native account of the transaction.
export.get_native_account_nonce
    push.NATIVE_ACCOUNT_DATA_PTR add.ACCT_NONCE_OFFSET
    mem_load
end

#! Sets the nonce of the current account.
#!
#! Inputs:  [nonce]
#! Outputs: []
#!
#! Where:
#! - nonce is the nonce of the current account.
export.set_account_nonce
    exec.get_current_account_data_ptr add.ACCT_ID_AND_NONCE_OFFSET padw
    # => [0, 0, 0, 0, account_id_and_nonce_ptr, new_nonce]
    dup.4 mem_loadw
    # => [old_nonce, 0, old_id_prefix, old_id_suffix, account_id_and_nonce_ptr, new_nonce]
    drop movup.4 movup.4 mem_storew dropw
    # => []
end

### ACCOUNT VAULT #################################################

#! Returns the memory pointer to the account vault root.
#!
#! Inputs:  []
#! Outputs: [account_vault_root_ptr]
#!
#! Where:
#! - account_vault_root_ptr is the memory pointer to the account asset vault root.
export.get_account_vault_root_ptr
    exec.get_current_account_data_ptr add.ACCT_VAULT_ROOT_OFFSET
end

#! Returns the account vault root.
#!
#! Inputs:  []
#! Outputs: [ACCT_VAULT_ROOT]
#!
#! Where:
#! - ACCT_VAULT_ROOT is the account asset vault root.
export.get_account_vault_root
    padw
    exec.get_current_account_data_ptr add.ACCT_VAULT_ROOT_OFFSET
    mem_loadw
end

#! Sets the account vault root.
#!
#! Inputs:  [ACCT_VAULT_ROOT]
#! Outputs: [ACCT_VAULT_ROOT]
#!
#! Where:
#! - ACCT_VAULT_ROOT is the account vault root to be set.
export.set_account_vault_root
    exec.get_current_account_data_ptr add.ACCT_VAULT_ROOT_OFFSET
    mem_storew
end

#! Returns the memory pointer to the initial vault root of the current account.
#!
#! For the native account, this returns the pointer to the initial vault root.
#! For foreign accounts, this returns the regular vault root pointer since foreign accounts
#! are read-only and their initial and current vault state always matches.
#!
#! Inputs:  []
#! Outputs: [account_initial_vault_root_ptr]
#!
#! Where:
#! - account_initial_vault_root_ptr is the memory pointer to the initial vault root.
export.get_account_initial_vault_root_ptr
    # For foreign account, use the regular vault root pointer since foreign accounts are read-only 
    # and initial == current
    exec.get_account_vault_root_ptr
    # => [account_vault_root_ptr]

    # For native account, use the initial vault root pointer
    exec.get_init_native_account_vault_root_ptr
    # => [native_account_initial_vault_root_ptr, account_vault_root_ptr]

    # get the flag indicating whether the current account is native
    exec.is_native_account
    # => [is_native_account, native_account_initial_vault_root_ptr, account_vault_root_ptr]

    # according to the is_native_account flag, return the corresponding pointer
    cdrop
    # => [account_initial_vault_root_ptr]
end

### ACCOUNT CODE #################################################

#! Returns the code commitment of the account.
#!
#! Inputs:  []
#! Outputs: [CODE_COMMITMENT]
#!
#! Where:
#! - CODE_COMMITMENT is the code commitment of the account.
export.get_account_code_commitment
    padw
    exec.get_current_account_data_ptr add.ACCT_CODE_COMMITMENT_OFFSET
    mem_loadw
end

#! Sets the code commitment of the account.
#!
#! Inputs:  [CODE_COMMITMENT]
#! Outputs: [CODE_COMMITMENT]
#!
#! Where:
#! - CODE_COMMITMENT is the code commitment to be set.
export.set_account_code_commitment
    exec.get_current_account_data_ptr add.ACCT_CODE_COMMITMENT_OFFSET
    mem_storew
end

#! Sets the transaction expiration block number.
#!
#! Inputs:  [tx_expiration_block_num]
#! Outputs: []
#!
#! Where:
#! - tx_expiration_block_num is the number of the transaction expiration block.
export.set_expiration_block_num
    mem_store.TX_EXPIRATION_BLOCK_NUM_PTR
end

#! Gets the transaction expiration block number.
#!
#! Inputs:  []
#! Outputs: [tx_expiration_block_num]
#!
#! Where:
#! - tx_expiration_block_num is the number of the transaction expiration block.
export.get_expiration_block_num
    mem_load.TX_EXPIRATION_BLOCK_NUM_PTR
end

#! Returns the number of procedures contained in the account code.
#!
#! Inputs:  []
#! Outputs: [num_procedures]
#!
#! Where:
#! - num_procedures is the number of procedures contained in the account code.
export.get_num_account_procedures
    exec.get_current_account_data_ptr add.NUM_ACCT_PROCEDURES_OFFSET
    mem_load
end

#! Sets the number of procedures contained in the account code.
#!
#! Inputs:  [num_procedures]
#! Outputs: []
#!
#! Where:
#! - num_procedures is the number of procedures contained in the account code.
export.set_num_account_procedures
    exec.get_current_account_data_ptr add.NUM_ACCT_PROCEDURES_OFFSET
    mem_store
end

#! Returns the memory pointer to the account procedures section.
#!
#! Inputs:  []
#! Outputs: [account_procedures_section_ptr]
#!
#! Where:
#! - account_procedures_section_ptr is the memory pointer to the account procedures section.
export.get_account_procedures_section_ptr
    exec.get_current_account_data_ptr add.ACCT_PROCEDURES_SECTION_OFFSET
end

#! Returns the memory pointer to the account procedures call tracking section.
#!
#! Inputs:  []
#! Outputs: [procedures_call_tracking_ptr]
#!
#! Where:
#! - procedures_call_tracking_ptr is the memory pointer to the procedure call tracking section.
export.get_account_procedures_call_tracking_ptr
    exec.get_current_account_data_ptr add.ACCT_PROCEDURES_CALL_TRACKING_OFFSET
end

#! Returns the memory pointer to a specific account procedure.
#!
#! Inputs:  [proc_idx]
#! Outputs: [proc_ptr]
#!
#! Where:
#! - proc_idx is the index of the account procedure.
#! - proc_ptr is the memory pointer to the account procedure at the specified index.
export.get_account_procedure_ptr
    mul.8 exec.get_account_procedures_section_ptr add
end

### ACCOUNT STORAGE #################################################

#! Returns the account storage commitment.
#!
#! Inputs:  []
#! Outputs: [STORAGE_COMMITMENT]
#!
#! Where:
#! - STORAGE_COMMITMENT is the account storage commitment.
export.get_account_storage_commitment
    padw
    exec.get_current_account_data_ptr add.ACCT_STORAGE_COMMITMENT_OFFSET
    mem_loadw
end

#! Sets the account storage commitment.
#!
#! Inputs:  [STORAGE_COMMITMENT]
#! Outputs: [STORAGE_COMMITMENT]
#!
#! Where:
#! - STORAGE_COMMITMENT is the account storage commitment.
export.set_account_storage_commitment
    exec.get_current_account_data_ptr add.ACCT_STORAGE_COMMITMENT_OFFSET
    mem_storew
end

#! Sets the dirty flag for the native account storage commitment.
#!
#! This binary flag specifies whether the storage commitment stored in the native account data is
#! outdated.
#!
#! Inputs:  [dirty_flag]
#! Outputs: []
#!
#! Where:
#! - dirty_flag is the flag indicating whether the storage commitment is outdated.
export.set_native_account_storage_commitment_dirty_flag
    push.NATIVE_ACCT_STORAGE_COMMITMENT_DIRTY_FLAG_PTR mem_store
    # => []
end

#! Returns the flag indicating whether the account storage commitment should be recomputed.
#!
#! This flag equals 1 if the current account is native and the storage commitment is outdated.
#!
#! Inputs:  []
#! Outputs: [should_recompute_storage_commitment]
#!
#! Where:
#! - should_recompute_storage_commitment is the flag indicating whether the storage commitment
#!   should be recomputed.
export.get_recompute_storage_commitment_flag
    # get the is_native_account flag
    exec.is_native_account
    # => [is_native_account]

    # get the storage commitment dirty flag
    mem_load.NATIVE_ACCT_STORAGE_COMMITMENT_DIRTY_FLAG_PTR
    # => [dirty_flag, is_native_account]

    # commitment should be recomputed only if the account is native and the commitment is outdated
    and
    # => [should_recompute_storage_commitment]
end

#! Returns the number of storage slots contained in the account storage.
#!
#! Inputs:  []
#! Outputs: [num_storage_slots]
#!
#! Where:
#! - num_storage_slots is the number of storage slots contained in the account storage.
export.get_num_storage_slots
    exec.get_current_account_data_ptr add.NUM_ACCT_STORAGE_SLOTS_OFFSET
    mem_load
end

#! Sets the number of storage slots contained in the account storage.
#!
#! Inputs:  [num_storage_slots]
#! Outputs: []
#!
#! Where:
#! - num_storage_slots is the number of storage slots contained in the account storage.
export.set_num_storage_slots
    exec.get_current_account_data_ptr add.NUM_ACCT_STORAGE_SLOTS_OFFSET
    mem_store
end

#! Returns the type of the requested storage slot.
#!
#! Inputs:  [account_storage_slots_section_ptr, index]
#! Outputs: [slot_type]
#!
#! Where:
#! - index is the location in memory of the storage slot.
#! - slot_type is the type of the storage slot.
export.get_storage_slot_type
    # get storage slot type
    swap mul.8 add add.4 mem_load
    # => [slot_type]
end

#! Returns the memory pointer to the account storage slots section.
#!
#! Inputs:  []
#! Outputs: [storage_slots_section_ptr]
#!
#! Where:
#! - storage_slots_section_ptr is the memory pointer to the account storage slots section.
export.get_account_storage_slots_section_ptr
    exec.get_current_account_data_ptr add.ACCT_STORAGE_SLOTS_SECTION_OFFSET
end

#! Returns the memory pointer to the native account's storage slots section.
#!
#! Inputs:  []
#! Outputs: [storage_slots_section_ptr]
#!
#! Where:
#! - storage_slots_section_ptr is the memory pointer to the native account's storage slots section.
export.get_native_account_storage_slots_ptr
    exec.get_native_account_data_ptr add.ACCT_STORAGE_SLOTS_SECTION_OFFSET
end

#! Returns the memory pointer to the initial storage slots of the native account.
#!
#! Inputs:  []
#! Outputs: [account_initial_storage_slots_ptr]
#!
#! Where:
#! - account_initial_storage_slots_ptr is the memory pointer to the initial storage slot values.
export.get_native_account_initial_storage_slots_ptr
  exec.get_native_account_data_ptr add.ACCT_INITIAL_STORAGE_SLOTS_SECTION_OFFSET
end

#! Returns the memory pointer to the initial storage slots of the current account.
#!
#! For the native account, this returns the pointer to the initial storage slots section.
#! For foreign accounts, this returns the regular storage slots pointer since foreign accounts
#! are read-only and their initial and current storage state always matches.
#!
#! Inputs:  []
#! Outputs: [account_initial_storage_slots_ptr]
#!
#! Where:
#! - account_initial_storage_slots_ptr is the memory pointer to the initial storage slot values.
export.get_account_initial_storage_slots_ptr
    # For foreign account, use the regular storage slots pointer since foreign accounts are 
    # read-only and initial == current
    exec.get_account_storage_slots_section_ptr
    # => [account_storage_slots_ptr]

    # For native account, use the initial storage slots pointer
    exec.get_native_account_initial_storage_slots_ptr
    # => [native_account_initial_storage_slots_ptr, account_storage_slots_ptr]

    # get the flag indicating whether the current account is native
    exec.is_native_account
    # => [is_native_account, native_account_initial_storage_slots_ptr, account_storage_slots_ptr]

    # according to the is_native_account flag, return the corresponding pointer
    cdrop
    # => [account_initial_storage_slots_ptr]
end

### ACCOUNT DELTA #################################################

#! Returns the link map pointer to the fungible asset vault delta.
#!
#! Inputs:  []
#! Outputs: [account_delta_fungible_asset_ptr]
#!
#! Where:
#! - account_delta_fungible_asset_ptr is the link map pointer to the fungible asset vault delta.
export.get_account_delta_fungible_asset_ptr
    push.ACCOUNT_DELTA_FUNGIBLE_ASSET_PTR
end

#! Returns the link map pointer to the non-fungible asset vault delta.
#!
#! Inputs:  []
#! Outputs: [account_delta_non_fungible_asset_ptr]
#!
#! Where:
#! - account_delta_non_fungible_asset_ptr is the link map pointer to the non-fungible asset vault delta.
export.get_account_delta_non_fungible_asset_ptr
    push.ACCOUNT_DELTA_NON_FUNGIBLE_ASSET_PTR
end

#! Returns the link map pointer to the storage map delta of the storage map in the given slot index.
#!
#! Inputs:  [slot_idx]
#! Outputs: [account_delta_storage_map_ptr]
#!
#! Where:
#! - account_delta_storage_map_ptr is the link map pointer to the storage map delta for the
#!   requested slot index.
export.get_account_delta_storage_map_ptr
    add.ACCOUNT_DELTA_STORAGE_MAP_SECTION
end

#! Initializes the storage slots holding the initial values of each slot.
#!
#! Inputs:  []
#! Outputs: []
export.mem_copy_initial_storage_slots
  exec.get_native_account_initial_storage_slots_ptr
  exec.get_native_account_storage_slots_ptr
  # => [storage_slots_section_ptr, initial_storage_slots_ptr]

  # each slot takes up two words
  exec.get_num_storage_slots mul.2
  # => [num_storage_slot_words, storage_slots_section_ptr, initial_storage_slots_ptr]

  exec.mem::memcopy_words
  # => []
end

# INPUT NOTES
# -------------------------------------------------------------------------------------------------

#! Returns the total number of input notes consumed by this transaction.
#!
#! Inputs:  []
#! Outputs: [num_input_notes]
#!
#! Where:
#! - num_input_notes is the total number of input notes consumed by this transaction.
export.get_num_input_notes
    mem_load.NUM_INPUT_NOTES_PTR
end

#! Sets the total number of input notes in the transaction.
#!
#! Inputs:  [num_input_notes]
#! Outputs: []
#!
#! Where:
#! - num_input_notes is the total number of input notes consumed by this transaction.
export.set_num_input_notes
    mem_store.NUM_INPUT_NOTES_PTR
end

#! Computes a pointer to the memory address at which the data associated with an input note with
#! index `idx` is stored.
#!
#! Inputs:  [idx]
#! Outputs: [note_ptr]
#!
#! Where:
#! - idx is the index of the input note.
#! - note_ptr is the memory address of the data segment for the input note with `idx`.
export.get_input_note_ptr
    exec.constants::get_note_mem_size mul add.INPUT_NOTE_DATA_SECTION_OFFSET
end

#! Set the note id of the input note.
#!
#! Inputs:  [note_ptr, NOTE_ID]
#! Outputs: [NOTE_ID]
#!
#! Where:
#! - note_ptr is the input note's the memory address.
#! - NOTE_ID is the note's id.
export.set_input_note_id
    mem_storew
end

#! Computes a pointer to the memory address at which the nullifier associated a note with `idx` is
#! stored.
#!
#! Inputs:  [idx]
#! Outputs: [nullifier_ptr]
#!
#! Where:
#! - idx is the index of the input note.
#! - nullifier_ptr is the memory address of the nullifier for note idx.
export.get_input_note_nullifier_ptr
    mul.4 add.INPUT_NOTE_NULLIFIER_SECTION_PTR
end

#! Returns the nullifier of an input note with `idx`.
#!
#! Inputs:  [idx]
#! Outputs: [nullifier]
#!
#! Where:
#! - idx is the index of the input note.
#! - nullifier is the nullifier of the input note.
export.get_input_note_nullifier
    mul.4 padw movup.4 add.INPUT_NOTE_NULLIFIER_SECTION_PTR mem_loadw
end

#! Returns a pointer to the start of the input note core data segment for the note located at the
#! specified memory address.
#!
#! Inputs:  [note_ptr]
#! Outputs: [note_data_ptr]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - note_data_ptr is the memory address at which the input note core data begins.
export.get_input_note_core_ptr
    add.INPUT_NOTE_CORE_DATA_OFFSET
end

#! Returns the script root of an input note located at the specified memory address.
#!
#! Inputs:  [note_ptr]
#! Outputs: [SCRIPT_ROOT]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - SCRIPT_ROOT is the script root of the input note.
export.get_input_note_script_root
    padw
    movup.4 add.INPUT_NOTE_SCRIPT_ROOT_OFFSET
    mem_loadw
end

#! Returns the memory address of the script root of an input note.
#!
#! Inputs:  [note_ptr]
#! Outputs: [script_root_ptr]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - script_root_ptr is the memory address where script root of the input note is stored.
export.get_input_note_script_root_ptr
    add.INPUT_NOTE_SCRIPT_ROOT_OFFSET
end

#! Returns the inputs commitment of an input note located at the specified memory address.
#!
#! Inputs:  [note_ptr]
#! Outputs: [INPUTS_COMMITMENT]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - INPUTS_COMMITMENT is the inputs commitment of the input note.
export.get_input_note_inputs_commitment
    padw
    movup.4 add.INPUT_NOTE_INPUTS_COMMITMENT_OFFSET
    mem_loadw
end

#! Returns the metadata of an input note located at the specified memory address.
#!
#! Inputs:  [note_ptr]
#! Outputs: [METADATA]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - METADATA is the metadata of the input note.
export.get_input_note_metadata
    padw
    movup.4 add.INPUT_NOTE_METADATA_OFFSET
    mem_loadw
end

#! Sets the metadata for an input note located at the specified memory address.
#!
#! Inputs:  [note_ptr, NOTE_METADATA]
#! Outputs: [NOTE_METADATA]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - NOTE_METADATA is the metadata of the input note.
export.set_input_note_metadata
    add.INPUT_NOTE_METADATA_OFFSET
    mem_storew
end

#! Returns the note's args.
#!
#! Inputs:  [note_ptr]
#! Outputs: [NOTE_ARGS]
#!
#! Where:
#! - note_ptr is the start memory address of the note.
#! - NOTE_ARGS are the note's args.
export.get_input_note_args
    padw
    movup.4 add.INPUT_NOTE_ARGS_OFFSET
    mem_loadw
end

#! Sets the note args for an input note located at the specified memory address.
#!
#! Inputs:  [note_ptr, NOTE_ARGS]
#! Outputs: [NOTE_ARGS]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - NOTE_ARGS are optional note args of the input note.
export.set_input_note_args
    add.INPUT_NOTE_ARGS_OFFSET
    mem_storew
end

#! Returns the number of inputs of the note located at the specified memory address.
#!
#! Inputs:  [note_ptr]
#! Outputs: [num_inputs]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - num_inputs is the number of inputs in in the input note.
export.get_input_note_num_inputs
    add.INPUT_NOTE_NUM_INPUTS_OFFSET
    mem_load
end

#! Sets the number of inputs for an input note located at the specified memory address.
#!
#! Inputs:  [note_ptr, num_inputs]
#! Outputs: []
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - num_inputs is the number of inputs in the input note.
export.set_input_note_num_inputs
    add.INPUT_NOTE_NUM_INPUTS_OFFSET
    mem_store
end

#! Returns the number of assets in the input note located at the specified memory address.
#!
#! Inputs:  [note_ptr]
#! Outputs: [num_assets]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - num_assets is the number of assets in the input note.
export.get_input_note_num_assets
    add.INPUT_NOTE_NUM_ASSETS_OFFSET
    mem_load
end

#! Sets the number of assets for an input note located at the specified memory address.
#!
#! Inputs:  [note_ptr, num_assets]
#! Outputs: []
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - num_assets is the number of assets in the input note.
export.set_input_note_num_assets
    add.INPUT_NOTE_NUM_ASSETS_OFFSET
    mem_store
end

#! Returns a pointer to the start of the assets segment for the input note located at the specified
#! memory address.
#!
#! Inputs:  [note_ptr]
#! Outputs: [assets_ptr]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - assets_ptr is the memory address at which the assets segment for the input note begins.
export.get_input_note_assets_ptr
    add.INPUT_NOTE_ASSETS_OFFSET
end

#! Returns the input note recipient.
#!
#! Inputs:  [note_ptr]
#! Outputs: [RECIPIENT]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - RECIPIENT is the commitment to the note's script, inputs and the serial number.
export.get_input_note_recipient
    padw
    movup.4 add.INPUT_NOTE_RECIPIENT_OFFSET
    mem_loadw
end

#! Sets the input note's recipient.
#!
#! Inputs:  [note_ptr, RECIPIENT]
#! Outputs: [RECIPIENT]
#!
#! Where:
#! - note_ptr is the memory address at which the output note data begins.
#! - RECIPIENT is the commitment to the note's script, inputs and the serial number.
export.set_input_note_recipient
    add.INPUT_NOTE_RECIPIENT_OFFSET
    mem_storew
end

#! Returns the assets commitment for the input note located at the specified memory address.
#!
#! Inputs:  [note_ptr]
#! Outputs: [ASSET_COMMITMENT]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - ASSET_COMMITMENT is the sequential hash of the padded assets of an input note.
export.get_input_note_assets_commitment
    padw
    movup.4 add.INPUT_NOTE_ASSETS_COMMITMENT_OFFSET
    mem_loadw
end

#! Returns the serial number for the input note located at the specified memory address.
#!
#! Inputs:  [note_ptr]
#! Outputs: [SERIAL_NUMBER]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - SERIAL_NUMBER is the input note's serial number.
export.get_input_note_serial_num
    padw
    movup.4 add.INPUT_NOTE_SERIAL_NUM_OFFSET
    mem_loadw
end

#! Returns the sender for the input note located at the specified memory address.
#!
#! Inputs:  [note_ptr]
#! Outputs: [sender_id_prefix, sender_id_suffix]
#!
#! Where:
#! - note_ptr is the memory address at which the input note data begins.
#! - sender is the sender for the input note.
export.get_input_note_sender
    padw
    movup.4 add.INPUT_NOTE_METADATA_OFFSET
    mem_loadw
    # => [aux, merged_tag_hint_payload, merged_sender_id_type_hint_tag, sender_id_prefix]

    drop drop
    # => [merged_sender_id_type_hint_tag, sender_id_prefix]

    # extract suffix of sender from merged layout, which means clearing the least significant byte
    u32split swap
    # => [merged_lo, merged_hi, sender_id_prefix]

    # clear least significant byte
    u32and.0xffffff00 swap
    # => [sender_id_suffix_hi, sender_id_suffix_lo, sender_id_prefix]

    # reassemble the suffix by multiplying the high part with 2^32 and adding the lo part
    mul.0x0100000000 add swap
    # => [sender_id_prefix, sender_id_suffix]
end

# OUTPUT NOTES
# -------------------------------------------------------------------------------------------------

#! Returns the offset of the output note data segment.
#!
#! Inputs:  []
#! Outputs: [offset]
#!
#! Where:
#! - offset is the offset of the output note data segment.
export.get_output_note_data_offset
    push.OUTPUT_NOTE_SECTION_OFFSET
end

#! Computes a pointer to the memory address at which the data associated with an output note with
#! index `i` is stored.
#!
#! Inputs:  [i]
#! Outputs: [ptr]
#!
#! Where:
#! - i is the index of the output note.
#! - ptr is the memory address of the data segment for output note i.
export.get_output_note_ptr
    exec.constants::get_note_mem_size mul add.OUTPUT_NOTE_SECTION_OFFSET
end

#! Returns the output note recipient.
#!
#! Inputs:  [note_ptr]
#! Outputs: [RECIPIENT]
#!
#! Where:
#! - note_ptr is the memory address at which the output note data begins.
#! - RECIPIENT is the commitment to the note's script, inputs and the serial number.
export.get_output_note_recipient
    padw
    movup.4 add.OUTPUT_NOTE_RECIPIENT_OFFSET
    mem_loadw
end

#! Sets the output note's recipient.
#!
#! Inputs:  [note_ptr, RECIPIENT]
#! Outputs: [RECIPIENT]
#!
#! Where:
#! - note_ptr is the memory address at which the output note data begins.
#! - RECIPIENT is the commitment to the note's script, inputs and the serial number.
export.set_output_note_recipient
    add.OUTPUT_NOTE_RECIPIENT_OFFSET
    mem_storew
end

#! Returns the output note's metadata.
#!
#! Inputs:  [note_ptr]
#! Outputs: [METADATA]
#!
#! Where:
#! - METADATA is the note metadata.
#! - note_ptr is the memory address at which the output note data begins.
export.get_output_note_metadata
    padw
    # => [0, 0, 0, 0, note_ptr]
    movup.4 add.OUTPUT_NOTE_METADATA_OFFSET
    # => [(note_ptr + offset), 0, 0, 0, 0]
    mem_loadw
    # => [METADATA]
end

#! Sets the output note's metadata.
#!
#! Inputs:  [note_ptr, METADATA]
#! Outputs: [METADATA]
#!
#! Where:
#! - METADATA is the note metadata.
#! - note_ptr is the memory address at which the output note data begins.
export.set_output_note_metadata
    add.OUTPUT_NOTE_METADATA_OFFSET
    mem_storew
end

#! Returns the number of assets in the output note.
#!
#! Inputs:  [note_ptr]
#! Outputs: [num_assets]
#!
#! Where:
#! - note_ptr is a pointer to the memory address at which the output note is stored.
#! - num_assets is the number of assets in the output note.
export.get_output_note_num_assets
    add.OUTPUT_NOTE_NUM_ASSETS_OFFSET mem_load
end

#! Sets the number of assets in the output note.
#!
#! Inputs:  [note_ptr, num_assets]
#! Outputs: []
#!
#! Where:
#! - note_ptr is the memory address at which the output note data begins.
#! - num_assets is the number of assets in the output note.
#!
#! Panics if:
#! - the number of assets exceeds the maximum allowed number of assets per note.
export.set_output_note_num_assets
    add.OUTPUT_NOTE_NUM_ASSETS_OFFSET
    # => [note_ptr + offset, num_assets]

    # check note number of assets limit
    dup.1 exec.constants::get_max_assets_per_note lt assert.err=ERR_NOTE_NUM_OF_ASSETS_EXCEED_LIMIT

    mem_store
end

#! Returns the dirty flag for the assets commitment.
#!
#! This binary flag specifies whether the assets commitment stored in the specified note is
#! outdated.
#!
#! Inputs:  [output_note_data_ptr]
#! Outputs: [dirty_flag]
#!
#! Where:
#! - output_note_data_ptr is the memory address at which the output note data begins.
#! - dirty_flag is the flag indicating whether the assets commitment is outdated.
export.get_output_note_dirty_flag
    add.OUTPUT_NOTE_DIRTY_FLAG_OFFSET mem_load
end

#! Sets the dirty flag for the assets commitment.
#!
#! This binary flag specifies whether the assets commitment stored in the specified note is
#! outdated.
#!
#! Inputs:  [output_note_data_ptr, dirty_flag]
#! Outputs: []
#!
#! Where:
#! - output_note_data_ptr is the memory address at which the output note data begins.
#! - dirty_flag is the flag indicating whether the assets commitment is outdated.
export.set_output_note_dirty_flag
    add.OUTPUT_NOTE_DIRTY_FLAG_OFFSET mem_store
end

#! Returns a pointer to the output note asset data.
#!
#! Inputs:  [output_note_data_ptr]
#! Outputs: [asset_data_ptr]
#!
#! Where:
#! - output_note_data_ptr is the memory address at which the output note data begins.
#! - asset_data_ptr is the memory address at which the output note asset data begins.
export.get_output_note_asset_data_ptr
    add.OUTPUT_NOTE_ASSETS_OFFSET
end

#! Returns the assets commitment for the output note located at the specified memory address.
#!
#! Inputs:  [output_note_data_ptr]
#! Outputs: [ASSETS_COMMITMENT]
#!
#! Where:
#! - output_note_data_ptr is the memory address at which the output note data begins.
#! - ASSETS_COMMITMENT is the sequential hash of the padded assets of an output note.
export.get_output_note_assets_commitment
    padw
    movup.4 add.OUTPUT_NOTE_ASSETS_COMMITMENT_OFFSET
    mem_loadw
end

#! Sets the output note assets commitment for the output note located at the specified memory
#! address.
#!
#! Inputs:  [output_note_data_ptr, ASSETS_COMMITMENT]
#! Outputs: [ASSETS_COMMITMENT]
#!
#! Where:
#! - output_note_data_ptr is the memory address at which the output note data begins.
#! - ASSETS_COMMITMENT is the sequential hash of the padded assets of an output note.
export.set_output_note_assets_commitment
    add.OUTPUT_NOTE_ASSETS_COMMITMENT_OFFSET
    mem_storew
end

# KERNEL DATA
# -------------------------------------------------------------------------------------------------

#! Sets the number of the procedures of the selected kernel.
#!
#! Inputs:  [num_kernel_procedures]
#! Outputs: []
#!
#! Where:
#! - num_kernel_procedures is the number of the procedures of the selected kernel.
export.set_num_kernel_procedures
    mem_store.NUM_KERNEL_PROCEDURES_PTR
end

#! Returns the number of the procedures of the selected kernel.
#!
#! Inputs:  []
#! Outputs: [num_kernel_procedures]
#!
#! Where:
#! - num_kernel_procedures is the number of the procedures of the selected kernel.
export.get_num_kernel_procedures
    mem_load.NUM_KERNEL_PROCEDURES_PTR
end

#! Returns a pointer to the memory where hashes of the kernel procedures are stored.
#!
#! Inputs:  []
#! Outputs: [kernel_procedures_ptr]
#!
#! Where:
#! - kernel_procedures_ptr is the memory address where the hashes of the kernel procedures are
#!   stored.
export.get_kernel_procedures_ptr
    push.KERNEL_PROCEDURES_PTR
end

# LINK MAP
# -------------------------------------------------------------------------------------------------

#! Returns the link map memory start ptr constant.
#!
#! Inputs:  []
#! Outputs: [start_ptr]
export.get_link_map_region_start_ptr
    push.LINK_MAP_REGION_START_PTR
end

#! Returns the link map memory end ptr constant.
#!
#! Inputs:  []
#! Outputs: [end_ptr]
export.get_link_map_region_end_ptr
    push.LINK_MAP_REGION_END_PTR
end

#! Returns the link map entry size constant.
#!
#! Inputs:  []
#! Outputs: [entry_size]
export.get_link_map_entry_size
    push.LINK_MAP_ENTRY_SIZE
end

#! Returns the next pointer to an empty link map entry.
#!
#! Inputs:  []
#! Outputs: [entry_ptr]
#!
#! Panics if:
#! - the allocation exceeds the maximum possible number of link map entries.
export.link_map_malloc
    # retrieve the current memory size
    mem_load.LINK_MAP_USED_MEMORY_SIZE dup
    # => [current_mem_size, current_mem_size]

    # store next offset
    add.LINK_MAP_ENTRY_SIZE
    # => [next_mem_size, current_mem_size]

    mem_store.LINK_MAP_USED_MEMORY_SIZE
    # => [current_mem_size]

    add.LINK_MAP_REGION_START_PTR
    # => [entry_ptr]

    # If entry_ptr is the end_ptr the entry would be allocated in the next memory region so
    # we must abort.
    # We can use neq because of how the end ptr is chosen. See its docs for details.
    dup neq.LINK_MAP_REGION_END_PTR assert.err=ERR_LINK_MAP_MAX_ENTRIES_EXCEEDED
    # => [entry_ptr]
end
