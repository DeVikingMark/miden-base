use.$kernel::account_delta
use.$kernel::account_id
use.$kernel::asset_vault
use.$kernel::constants
use.$kernel::memory

use.std::collections::smt
use.std::crypto::hashes::rpo
use.std::mem

# ERRORS
# =================================================================================================

const.ERR_ACCOUNT_NONCE_CAN_ONLY_BE_INCREMENTED_ONCE="account nonce can only be incremented once"

const.ERR_ACCOUNT_NONCE_AT_MAX="account nonce is already at its maximum possible value"

const.ERR_ACCOUNT_CODE_IS_NOT_UPDATABLE="account code must be updatable for it to be possible to set new code"

const.ERR_ACCOUNT_SEED_AND_COMMITMENT_DIGEST_MISMATCH="ID of the new account does not match the ID computed from the seed and commitments"

const.ERR_ACCOUNT_SETTING_VALUE_ITEM_ON_NON_VALUE_SLOT="failed to write an account value item to a non-value storage slot"

const.ERR_ACCOUNT_SETTING_MAP_ITEM_ON_NON_MAP_SLOT="failed to write an account map item to a non-map storage slot"

const.ERR_ACCOUNT_PROC_NOT_PART_OF_ACCOUNT_CODE="account procedure is not part of the account code"

const.ERR_ACCOUNT_PROC_INDEX_OUT_OF_BOUNDS="provided procedure index is out of bounds"

const.ERR_ACCOUNT_PROC_NOT_AUTH_PROC="account procedure is not the authentication procedure; some procedures (e.g. `incr_nonce`) can be called only from the authentication procedure"

const.ERR_ACCOUNT_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS="provided storage slot index is out of bounds"

const.ERR_FAUCET_INVALID_STORAGE_OFFSET="storage offset is invalid for a faucet account (0 is prohibited as it is the reserved data slot for faucets)"

const.ERR_ACCOUNT_CODE_COMMITMENT_MISMATCH="computed account code commitment does not match recorded account code commitment"

const.ERR_ACCOUNT_TOO_MANY_PROCEDURES="number of account procedures exceeds the maximum limit of 256"

const.ERR_ACCOUNT_TOO_MANY_STORAGE_SLOTS="number of account storage slots exceeds the maximum limit of 255"

const.ERR_ACCOUNT_STORAGE_COMMITMENT_MISMATCH="computed account storage commitment does not match recorded account storage commitment"

const.ERR_ACCOUNT_INVALID_STORAGE_OFFSET_FOR_SIZE="storage size can only be zero if storage offset is also zero"

const.ERR_FOREIGN_ACCOUNT_ID_IS_ZERO="ID of the provided foreign account equals zero"

const.ERR_FOREIGN_ACCOUNT_MAX_NUMBER_EXCEEDED="maximum allowed number of foreign account to be loaded (64) was exceeded"

const.ERR_FOREIGN_ACCOUNT_INVALID_COMMITMENT="commitment of the foreign account in the advice provider does not match the commitment in the account tree"

const.ERR_ACCOUNT_ID_UNKNOWN_VERSION="unknown version in account ID"

const.ERR_ACCOUNT_ID_UNKNOWN_STORAGE_MODE="unknown account storage mode in account ID"

const.ERR_ACCOUNT_READING_MAP_VALUE_FROM_NON_MAP_SLOT="failed to read an account map item from a non-map storage slot"

# CONSTANTS
# =================================================================================================

# The account storage slot at which faucet data is stored.
# Fungible faucet: The faucet data consists of [0, 0, 0, total_issuance]
# Non-fungible faucet: The faucet data consists of SMT root containing minted non-fungible assets.
const.FAUCET_STORAGE_DATA_SLOT=0

# The maximum storage slot index
const.MAX_STORAGE_SLOT_INDEX=254

# The maximum number of account storage slots.
const.MAX_NUM_STORAGE_SLOTS=MAX_STORAGE_SLOT_INDEX+1

# The maximum number of account interface procedures.
const.MAX_NUM_PROCEDURES=256

# Given the least significant 32 bits of an account ID's prefix, this mask defines the bits used
# to determine the account version.
const.ACCOUNT_VERSION_MASK_U32=0x0f # 0b1111

# Given the least significant 32 bits of an account ID's prefix, this mask defines the bits used
# to determine the account type.
const.ACCOUNT_ID_TYPE_MASK_U32=0x30 # 0b11_0000

# Given the least significant 32 bits of an account ID's first felt, this mask defines the bits used
# to determine the account storage mode.
const.ACCOUNT_ID_STORAGE_MODE_MASK_U32=0xC0 # 0b1100_0000

# Given the least significant 32 bits of an account ID's first felt with the storage mode mask
# applied, this value defines the public storage mode.
const.ACCOUNT_ID_STORAGE_MODE_PUBLIC_U32=0 # 0b0000_0000

# Given the least significant 32 bits of an account ID's first felt with the storage mode mask
# applied, this value defines the private storage mode.
const.ACCOUNT_ID_STORAGE_MODE_PRIVATE_U32=0x80 # 0b1000_0000

# Bit pattern for an account w/ immutable code, after the account type mask has been applied.
const.REGULAR_ACCOUNT_IMMUTABLE_CODE=0 # 0b00_0000

# Bit pattern for an account w/ updatable code, after the account type mask has been applied.
const.REGULAR_ACCOUNT_UPDATABLE_CODE=0x10 # 0b01_0000

# Bit pattern for a fungible faucet w/ immutable code, after the account type mask has been applied.
const.FUNGIBLE_FAUCET_ACCOUNT=0x20 # 0b10_0000

# Bit pattern for a non-fungible faucet w/ immutable code, after the account type mask has been
# applied.
const.NON_FUNGIBLE_FAUCET_ACCOUNT=0x30 # 0b11_0000

# Bit pattern for a faucet account, after the account type mask has been applied.
const.FAUCET_ACCOUNT=0x20 # 0b10_0000

# Depth of the account database tree.
const.ACCOUNT_TREE_DEPTH=64

# The number of field elements it takes to store one account storage slot.
const.ACCOUNT_STORAGE_SLOT_DATA_LENGTH=8

# The number of field elements it takes to store one account procedure.
const.ACCOUNT_PROCEDURE_DATA_LENGTH=8

# EVENTS
# =================================================================================================

# Event emitted before a foreign account is loaded from the advice inputs.
const.ACCOUNT_BEFORE_FOREIGN_LOAD_EVENT=event("miden::account::before_foreign_load")

# Event emitted before an asset is added to the account vault.
const.ACCOUNT_VAULT_BEFORE_ADD_ASSET_EVENT=event("miden::account::vault_before_add_asset")
# Event emitted after an asset is added to the account vault.
const.ACCOUNT_VAULT_AFTER_ADD_ASSET_EVENT=event("miden::account::vault_after_add_asset")

# Event emitted before an asset is removed from the account vault.
const.ACCOUNT_VAULT_BEFORE_REMOVE_ASSET_EVENT=event("miden::account::vault_before_remove_asset")
# Event emitted after an asset is removed from the account vault.
const.ACCOUNT_VAULT_AFTER_REMOVE_ASSET_EVENT=event("miden::account::vault_after_remove_asset")

# Event emitted before a fungible asset's balance is fetched from the account vault.
const.ACCOUNT_VAULT_BEFORE_GET_BALANCE_EVENT=event("miden::account::vault_before_get_balance")

# Event emitted before it is checked whether a non-fungible asset exists in the account vault.
const.ACCOUNT_VAULT_BEFORE_HAS_NON_FUNGIBLE_ASSET_EVENT=event("miden::account::vault_before_has_non_fungible_asset")

# Event emitted before an account storage item is updated.
const.ACCOUNT_STORAGE_BEFORE_SET_ITEM_EVENT=event("miden::account::storage_before_set_item")
# Event emitted after an account storage item is updated.
const.ACCOUNT_STORAGE_AFTER_SET_ITEM_EVENT=event("miden::account::storage_after_set_item")

# Event emitted before an account storage map item is accessed.
const.ACCOUNT_STORAGE_BEFORE_GET_MAP_ITEM_EVENT=event("miden::account::storage_before_get_map_item")

# Event emitted before an account storage map item is updated.
const.ACCOUNT_STORAGE_BEFORE_SET_MAP_ITEM_EVENT=event("miden::account::storage_before_set_map_item")
# Event emitted after an account storage map item is updated.
const.ACCOUNT_STORAGE_AFTER_SET_MAP_ITEM_EVENT=event("miden::account::storage_after_set_map_item")

# Event emitted before an account nonce is incremented.
const.ACCOUNT_BEFORE_INCREMENT_NONCE_EVENT=event("miden::account::before_increment_nonce")
# Event emitted after an account nonce is incremented.
const.ACCOUNT_AFTER_INCREMENT_NONCE_EVENT=event("miden::account::after_increment_nonce")

# Event emitted to push the index of the account procedure at the top of the operand stack onto
# the advice stack.
const.ACCOUNT_PUSH_PROCEDURE_INDEX_EVENT=event("miden::account::push_procedure_index")

# CONSTANT ACCESSORS
# =================================================================================================

#! Returns the account storage slot at which faucet data is stored.
#! Fungible faucet: The faucet data consists of [0, 0, 0, total_issuance]
#! Non-fungible faucet: The faucet data consists of SMT root containing minted non-fungible assets.
#!
#! Inputs:  []
#! Outputs: [faucet_storage_data_slot]
#!
#! Where:
#! - faucet_storage_data_slot is the account storage slot at which faucet data is stored.
export.get_faucet_storage_data_slot
    push.FAUCET_STORAGE_DATA_SLOT
end

#! Returns the maximum number of account storage slots.
#!
#! Inputs:  []
#! Outputs: [max_num_storage_slots]
#!
#! Where:
#! - max_num_storage_slots is the maximum number of account storage slots.
export.get_max_num_storage_slots
    push.MAX_NUM_STORAGE_SLOTS
end

#! Returns the maximum number of account interface procedures.
#!
#! Inputs:  []
#! Outputs: [max_num_procedures]
#!
#! Where:
#! - max_num_procedures is the maximum number of account interface procedures.
export.get_max_num_procedures
    push.MAX_NUM_PROCEDURES
end

# PROCEDURES
# =================================================================================================

#! Computes the account commitment of the current account.
#!
#! Notice that there is no caching (and, hence, dirty flag) for the commitment of the entire
#! account. Assuming that the storage commitment is current, computing account commitment is
#! relatively cheap — essentially is consists of just 2 permutations of the hash function and takes
#! relatively small number of cycles, so it would not be worth adding a separate caching mechanism
#! for this.
#!
#! Inputs:  []
#! Outputs: [ACCOUNT_COMMITMENT]
#!
#! Where:
#! - ACCOUNT_COMMITMENT is the commitment of the account data.
export.compute_current_commitment
    # if outdated, recompute the storage commitment and store it in the memory
    exec.refresh_storage_commitment
    # => []

    # prepare the stack for computing the account commitment
    exec.memory::get_current_account_data_ptr padw padw padw
    # => [RATE, RATE, PERM, account_data_ptr]

    # stream account data and compute sequential hash. We perform two `mem_stream` operations
    # because the account data consists of exactly 4 words.
    mem_stream hperm mem_stream hperm
    # => [RATE, RATE, PERM, account_data_ptr']

    # extract account commitment
    exec.rpo::squeeze_digest
    # => [ACCOUNT_COMMITMENT, account_data_ptr']

    # drop account_data_ptr
    movup.4 drop
    # => [ACCOUNT_COMMITMENT]
end

#! Increments the account nonce by one and returns the new nonce.
#!
#! Assumes that it is executed only when the current account is the native account.
#!
#! Inputs:  []
#! Outputs: [new_nonce]
#!
#! Panics if:
#! - the nonce has already been incremented.
export.incr_nonce
    exec.account_delta::was_nonce_incremented
    # => [was_nonce_incremented]

    # assert the nonce has not already been incremented
    assertz.err=ERR_ACCOUNT_NONCE_CAN_ONLY_BE_INCREMENTED_ONCE
    # => []

    # emit event to signal that account nonce is being incremented
    emit.ACCOUNT_BEFORE_INCREMENT_NONCE_EVENT

    exec.memory::get_account_nonce
    # => [current_nonce]

    # if the current nonce is the maximum felt value, then incrementing the nonce would overflow
    # the field
    dup neq.0xffffffff00000000 assert.err=ERR_ACCOUNT_NONCE_AT_MAX
    # => [current_nonce]

    add.1
    # => [new_nonce]

    dup exec.memory::set_account_nonce
    # => [new_nonce]

    emit.ACCOUNT_AFTER_INCREMENT_NONCE_EVENT
    # => [new_nonce]
end

#! Returns the id of the current account.
#!
#! Inputs:  []
#! Outputs: [curr_acct_id_prefix, curr_acct_id_suffix]
#!
#! Where:
#! - curr_acct_id_{prefix,suffix} are the prefix and suffix felts of the account ID of the currently
#!   accessing account.
export.memory::get_account_id->get_id

#! Returns the account nonce.
#!
#! Inputs:  []
#! Outputs: [nonce]
#!
#! Where:
#! - nonce is the account nonce.
export.memory::get_account_nonce->get_nonce

#! Returns the native account commitment at the beginning of the transaction.
#!
#! Inputs:  []
#! Outputs: [INIT_COMMITMENT]
#!
#! Where:
#! - INIT_COMMITMENT is the initial account commitment.
export.memory::get_init_account_commitment->get_initial_commitment

#! Returns the vault root of the native account at the beginning of the transaction.
#!
#! Inputs:  []
#! Outputs: [INIT_ACCOUNT_VAULT_ROOT]
#!
#! Where:
#! - INIT_ACCOUNT_VAULT_ROOT is the initial account vault root.
export.memory::get_init_native_account_vault_root->get_initial_vault_root

#! Returns the storage commitment of the native account at the beginning of the transaction.
#!
#! Inputs:  []
#! Outputs: [INIT_ACCOUNT_STORAGE_COMMITMENT]
#!
#! Where:
#! - INIT_ACCOUNT_STORAGE_COMMITMENT is the initial account storage commitment.
export.memory::get_init_account_storage_commitment->get_initial_storage_commitment

#! Gets the code commitment of the current account.
#!
#! Inputs:  []
#! Outputs: [CODE_COMMITMENT]
#!
#! Where:
#! - CODE_COMMITMENT is the commitment of the account code.
export.memory::get_account_code_commitment->get_code_commitment

#! Computes the storage commitment of the current account.
#!
#! Inputs:  []
#! Outputs: [STORAGE_COMMITMENT]
#!
#! Where:
#! - STORAGE_COMMITMENT is the current commitment of the account storage.
export.compute_storage_commitment
    # if outdated, recompute the storage commitment and store it in the memory
    exec.refresh_storage_commitment

    # return the storage commitment
    exec.memory::get_account_storage_commitment
    # => [STORAGE_COMMITMENT]
end

#! Applies storage offset to provided storage slot index for storage access.
#!
#! Inputs:  [storage_offset, storage_size, slot_index]
#! Outputs: [offset_slot_index]
#!
#! Where:
#! - storage_offset is the offset of the storage for this account component.
#! - storage_size is the number of storage slots accessible from this account component.
#! - slot_index is the index of the storage slot to be accessed.
#! - offset_slot_index is the final index of the storage slot with the storage offset applied to it.
#!
#! Panics if:
#! - the computed index is out of bounds
export.apply_storage_offset
    # offset index
    dup movup.3 add
    # => [offset_slot_index, storage_offset, storage_size]

    # verify that slot_index is in bounds
    movdn.2 add dup.1 gt assert.err=ERR_ACCOUNT_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
    # => [offset_slot_index]
end

#! Validates all account procedure's storage metadata.
#!
#! Inputs:  []
#! Outputs: []
#!
#! Panics if:
#! - Storage offset + storage size > number of storage slots.
#! - Storage size is zero and storage offset is non-zero.
#!   - This is validated to ensure users do not accidentally set a non-zero offset with a
#!     zero size which would prevent any access to storage.
#! - The storage offset of a faucet account's procedure is 0 with a size != 0.
#!   - This prevents access to the reserved storage slot.
export.validate_procedure_metadata
    # get number of account procedures and number of storage slots
    exec.memory::get_num_account_procedures exec.memory::get_num_storage_slots
    # => [num_storage_slots, num_account_procedures]

    # prepare stack for looping
    push.0.1
    # => [start_loop, index, num_storage_slots, num_account_procedures]

    # check if the account is a faucet
    exec.get_id swap drop exec.account_id::is_faucet
    # => [is_faucet, start_loop, index, num_storage_slots, num_account_procedures]

    # we do not check if num_account_procedures == 0 here because a valid
    # account has between 1 and 256 procedures with associated offsets
    if.true
        # This branch handles procedures from faucet accounts.
        while.true
            # get storage offset and size from memory
            dup exec.get_procedure_metadata
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # Procedures that do not access storage are defined with (offset, size) = (0, 0).
            # But we want to fail on tuples defined with a zero size but non-zero offset, since that
            # is a logic error.
            # We assert this with: (size == 0 && offset != 0) == 0.
            dup.1 eq.0 dup.1 eq.0 not and assertz.err=ERR_ACCOUNT_INVALID_STORAGE_OFFSET_FOR_SIZE
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # No procedure should access the reserved faucet slot (slot 0). However (0, 0) should
            # still be allowed per the above.
            # We assert this with: (offset == 0 && size != 0) == 0.
            dup.1 eq.0 not dup.1 eq.0 and assertz.err=ERR_FAUCET_INVALID_STORAGE_OFFSET
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # assert that storage limit is in bounds
            add dup.2 lte assert.err=ERR_ACCOUNT_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
            # => [index, num_storage_slots, num_account_procedures]

            # check if we should continue looping
            add.1 dup dup.3 lt
            # => [should_loop, index, num_storage_slots, num_account_procedures]
        end
    else
        # This branch handles procedures from regular accounts.
        while.true
            # get storage offset and size from memory
            dup exec.get_procedure_metadata
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # Procedures that do not access storage are defined with (offset, size) = (0, 0).
            # But we want to fail on tuples defined with a zero size but non-zero offset, since that
            # is a logic error.
            # We assert this with: (size == 0 && offset != 0) == 0.
            dup.1 eq.0 dup.1 eq.0 not and assertz.err=ERR_ACCOUNT_INVALID_STORAGE_OFFSET_FOR_SIZE
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # assert that storage limit is in bounds
            add dup.2 lte assert.err=ERR_ACCOUNT_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
            # => [index, num_storage_slots, num_account_procedures]

            # check if we should continue looping
            add.1 dup dup.3 lt
            # => [should_loop, index, num_storage_slots, num_account_procedures]
        end
    end

    # clean stack
    drop drop drop
    # => []
end

#! Gets an item from the account storage.
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Inputs:  [index]
#! Outputs: [VALUE]
#!
#! Where:
#! - index is the index of the item to get.
#! - VALUE is the value of the item.
export.get_item
    # get account storage slots section offset
    exec.memory::get_account_storage_slots_section_ptr
    # => [acct_storage_slots_section_offset, index]

    # get the item from storage
    exec.get_item_raw
    # => [VALUE]
end

#! Gets an item from the account storage at its initial state (beginning of transaction).
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Inputs:  [index]
#! Outputs: [INIT_VALUE]
#!
#! Where:
#! - index is the index of the item to get.
#! - INIT_VALUE is the initial value of the item at the beginning of the transaction.
export.get_initial_item
    # get account initial storage slots section offset
    exec.memory::get_account_initial_storage_slots_ptr
    # => [account_initial_storage_slots_ptr, index]

    # get the item from initial storage
    exec.get_item_raw
    # => [INIT_VALUE]
end

#! Sets an item in the account storage.
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Inputs:  [index, VALUE]
#! Outputs: [OLD_VALUE]
#!
#! Where:
#! - index is the index of the item to set.
#! - VALUE is the value to set.
#! - OLD_VALUE is the previous value of the item.
#!
#! Panics if:
#! - the storage slot type is not value.
export.set_item
    emit.ACCOUNT_STORAGE_BEFORE_SET_ITEM_EVENT
    # => [index, VALUE]

    # get storage slot type
    dup exec.get_storage_slot_type
    # => [storage_slot_type, index, VALUE]

    # check if type == slot
    exec.constants::get_storage_slot_type_value eq
    assert.err=ERR_ACCOUNT_SETTING_VALUE_ITEM_ON_NON_VALUE_SLOT
    # => [index, VALUE]

    # duplicate the index and the VALUE enabling emission of an
    # event after an account storage item is being updated
    movdn.4 dupw dup.8
    # => [index, VALUE, VALUE, index]

    # set VALUE in the storage slot
    exec.set_item_raw
    # => [OLD_VALUE, VALUE, index]

    # emit event to signal that an account storage item is being updated
    swapw movup.8
    emit.ACCOUNT_STORAGE_AFTER_SET_ITEM_EVENT drop dropw
    # => [OLD_VALUE]
end

#! Returns the VALUE located under the specified KEY within the map contained in the given
#! account storage slot.
#!
#! Inputs:  [index, KEY]
#! Outputs: [VALUE]
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Where:
#! - index is the index of the storage slot that contains the map root.
#! - VALUE is the value of the map item at KEY.
#!
#! Panics if:
#! - the requested storage slot type is not map.
export.get_map_item
    # duplicate index for later use
    dup movdn.5
    # => [index, KEY, index]

    # fetch the account storage item, which is ROOT of the map
    exec.get_item swapw
    # => [KEY, ROOT, index]

    exec.get_map_item_raw
end

#! Returns the VALUE located under the specified KEY within the map contained in the given
#! account storage slot at its initial state (beginning of transaction).
#!
#! Inputs:  [index, KEY]
#! Outputs: [INIT_VALUE]
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Where:
#! - index is the index of the storage slot that contains the map root.
#! - INIT_VALUE is the initial value of the map item at KEY at the beginning of the transaction.
#!
#! Panics if:
#! - the requested storage slot type is not map.
export.get_initial_map_item
    # duplicate index for later use
    dup movdn.5
    # => [index, KEY, index]

    # fetch the initial account storage item, which is ROOT of the map
    exec.get_initial_item swapw
    # => [KEY, INIT_ROOT, index]

    exec.get_map_item_raw
end

#! Stores NEW_VALUE under the specified KEY within the map contained in the given account storage slot.
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Inputs:  [index, KEY, NEW_VALUE]
#! Outputs: [OLD_MAP_ROOT, OLD_MAP_VALUE]
#!
#! Where:
#! - index is the index of the storage slot which contains the map root.
#! - NEW_VALUE is the value to set under KEY.
#! - KEY is the key to set.
#! - OLD_MAP_VALUE is the previous value of the item.
#! - OLD_MAP_ROOT is the root of the old map before insertion
#!
#! Panics if:
#! - the storage slot type is not map.
#! - no map is found for ROOT.
export.set_map_item.12
    # store index for later
    dup loc_store.0 exec.get_item
    # => [OLD_ROOT, KEY, NEW_VALUE, ...]

    movdnw.2 loc_load.0
    # => [index, KEY, NEW_VALUE, OLD_ROOT, ...]

    emit.ACCOUNT_STORAGE_BEFORE_SET_MAP_ITEM_EVENT
    # => [index, KEY, NEW_VALUE, OLD_ROOT, ...]

    # check if storage type is map
    exec.get_storage_slot_type
    # => [slot_type, KEY, NEW_VALUE, OLD_ROOT]

    # check if slot_type == map
    exec.constants::get_storage_slot_type_map eq
    assert.err=ERR_ACCOUNT_SETTING_MAP_ITEM_ON_NON_MAP_SLOT
    # => [KEY, NEW_VALUE, OLD_ROOT]

    # duplicate the original KEY and the NEW_VALUE to be able to emit an event after the
    # account storage item was updated
    movupw.2 dupw.2 dupw.2
    # => [KEY, NEW_VALUE, OLD_ROOT, KEY, NEW_VALUE]

    # see hash_map_key's docs for why this is done
    exec.hash_map_key
    # => [HASHED_KEY, NEW_VALUE, OLD_ROOT, KEY, NEW_VALUE]

    # set the NEW_VALUE under HASHED_KEY in the tree
    # note smt::set expects the stack to be [NEW_VALUE, HASHED_KEY, OLD_ROOT]
    swapw exec.smt::set
    # => [OLD_MAP_VALUE, NEW_ROOT, KEY, NEW_VALUE]

    # store OLD_MAP_VALUE and NEW_ROOT until the end of the procedure
    loc_storew.4 dropw loc_storew.8 dropw
    # => [KEY, NEW_VALUE]

    dupw.1
    # => [NEW_VALUE, KEY, NEW_VALUE]

    padw loc_loadw.4
    # => [OLD_MAP_VALUE, NEW_VALUE, KEY, NEW_VALUE]

    dupw.2
    # => [KEY, OLD_MAP_VALUE, NEW_VALUE, KEY, NEW_VALUE]

    # emit event to signal that an account storage item is being updated
    loc_load.0
    # => [index, KEY, OLD_MAP_VALUE, NEW_VALUE, KEY, NEW_VALUE]

    emit.ACCOUNT_STORAGE_AFTER_SET_MAP_ITEM_EVENT
    # => [index, KEY, OLD_MAP_VALUE, NEW_VALUE, KEY, NEW_VALUE]

    exec.account_delta::set_map_item
    # => [KEY, NEW_VALUE]

    # load OLD_MAP_VALUE and NEW_ROOT on the top of the stack
    loc_loadw.8 swapw loc_loadw.4 swapw
    # => [NEW_ROOT, OLD_MAP_VALUE, ...]

    # set the root of the map in the respective account storage slot
    loc_load.0 exec.set_item_raw
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE, ...]
end

#! Returns the type of the requested storage slot.
#!
#! Inputs:  [index]
#! Outputs: [slot_type]
#!
#! Where:
#! - index is the location in memory of the storage slot.
#! - slot_type is the type of the storage slot.
#!
#! Panics if:
#! - the slot index is out of bounds.
export.get_storage_slot_type
    # check that index is in bounds
    dup exec.memory::get_num_storage_slots lt assert.err=ERR_ACCOUNT_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
    # => [index]

    exec.memory::get_account_storage_slots_section_ptr
    # => [curr_account_storage_slots_section_ptr, index]

    exec.memory::get_storage_slot_type
    # => [slot_type]
end

#! Returns the procedure information.
#!
#! Inputs:  [index]
#! Outputs: [PROC_ROOT, storage_offset, storage_size]
#!
#! Where:
#! - PROC_ROOT is the hash of the procedure.
#! - storage_offset is the procedure storage offset.
#! - storage_size is the number of storage slots the procedure is allowed to access.
#!
#! Panics if:
#! - the procedure index is out of bounds.
export.get_procedure_info
    # check that index < number of procedures contained in the account code
    dup exec.memory::get_num_account_procedures
    u32assert2.err=ERR_ACCOUNT_PROC_INDEX_OUT_OF_BOUNDS u32lt assert.err=ERR_ACCOUNT_PROC_INDEX_OUT_OF_BOUNDS
    # => [index]

    # get procedure pointer
    exec.memory::get_account_procedure_ptr
    # => [proc_ptr]

    # get metadata pointer
    dup add.4 swap
    # => [proc_ptr, metadata_ptr]

    # load procedure information from memory
    padw movup.4 mem_loadw padw movup.8 mem_loadw
    # => [METADATA, PROC_ROOT]
    # more explicitly:
    # => [0, 0, storage_size, storage_offset, PROC_ROOT]

    # keep relevant data
    drop drop
    # => [storage_size, storage_offset, PROC_ROOT]

    swap movdn.5 movdn.5
    # => [PROC_ROOT, storage_offset, storage_size]
end

#! Verifies that the procedure root is part of the account code and tracks whether it has been
#! called.
#!
#! Inputs:  [PROC_ROOT]
#! Outputs: [storage_offset, storage_size]
#!
#! Where:
#! - PROC_ROOT is the hash of the procedure to authenticate.
#! - storage_offset is the procedure storage offset.
#! - storage_size is the number of storage slots the procedure is allowed to access.
#!
#! Panics if:
#! - the procedure root is not part of the account code.
export.authenticate_and_track_procedure
    # load procedure index
    emit.ACCOUNT_PUSH_PROCEDURE_INDEX_EVENT adv_push.1
    # => [index, PROC_ROOT]

    dup movdn.5
    # get procedure info (PROC_ROOT, storage_offset, storage_size) from memory stored at index
    exec.get_procedure_info
    # => [MEM_PROC_ROOT, storage_offset, storage_size, PROC_ROOT, index]

    # verify that PROC_ROOT exists in memory at index
    movup.4 movdn.9 movup.4 movdn.9 assert_eqw.err=ERR_ACCOUNT_PROC_NOT_PART_OF_ACCOUNT_CODE
    # => [storage_offset, storage_size, index]

    # Set the was_called flag to 1 for this procedure
    movup.2 exec.set_was_procedure_called

    # => [storage_offset, storage_size]
end

#! Asserts that the specified procedure root is the root of the authentication procedure for an
#! account. This procedure is assumed to be invoked after asserting the account is a native account.
#!
#! Inputs:  [PROC_ROOT]
#! Outputs: []
#!
#! Where:
#! - PROC_ROOT is the hash of the procedure to authenticate.
#!
#! Panics if:
#! - the procedure root is not the authentication procedure.
export.assert_auth_procedure
    # authentication procedure is always at index 0
    push.0
    # => [index, PROC_ROOT]

    # set was_called for the the auth procedure to true
    dup exec.set_was_procedure_called
    # => [index, PROC_ROOT]

    # get procedure info (PROC_ROOT, storage_offset, storage_size) from memory stored at index
    exec.get_procedure_root
    # => [MEM_PROC_ROOT, PROC_ROOT]

    # verify that PROC_ROOT exists in memory at index
    assert_eqw.err=ERR_ACCOUNT_PROC_NOT_AUTH_PROC
    # => []
end

#! Validates that the account seed, provided via the advice map, satisfies the seed requirements.
#!
#! Validation is performed via the following steps:
#! 1. Compute the hash of (SEED, CODE_COMMITMENT, STORAGE_COMMITMENT, EMPTY_WORD).
#! 2. Assert the two least significant elements of the digest are equal to the account ID of the
#!    account the transaction is being executed against.
#!
#! Inputs:  []
#! Outputs: []
export.validate_seed
    # Compute the hash of (SEED, CODE_COMMITMENT, STORAGE_COMMITMENT, EMPTY_WORD).
    # ---------------------------------------------------------------------------------------------

    # push an empty word as padding for account ID hashing
    padw
    # => [EMPTY_WORD]

    # push the advice map key at which the seed is located
    exec.memory::get_account_id push.0.0
    # => [0, 0, account_id_prefix, account_id_suffix, EMPTY_WORD]

    # populate first four elements of the rate with the account ID seed
    adv.push_mapval adv_loadw
    # => [SEED, EMPTY_WORD]

    # pad capacity element of hasher
    padw swapw
    # => [SEED, 0, 0, 0, 0, EMPTY_WORD]

    # populate last four elements of the hasher rate with the code commitment
    exec.memory::get_account_code_commitment
    # => [CODE_COMMITMENT, SEED, 0, 0, 0, 0, EMPTY_WORD]

    # perform first permutation of seed and code_commitment (from advice stack)
    # perm(seed, code_commitment)
    hperm
    # => [RATE, RATE, PERM, EMPTY_WORD]

    # clear rate elements
    dropw dropw
    # => [PERM, EMPTY_WORD]

    # perform second permutation perm(storage_commitment, 0, 0, 0, 0)
    swapw exec.memory::get_account_storage_commitment swapw
    # => [EMPTY_WORD, STORAGE_COMMITMENT, PERM]

    hperm
    # => [RATE, RATE, CAP]

    # extract digest
    exec.rpo::squeeze_digest
    # => [DIGEST]

    # Shape suffix to set the lower 8 bits to zero and compare the computed and provided ID.
    # ---------------------------------------------------------------------------------------------

    # extract account ID from digest
    drop drop swap
    # => [hashed_account_id_prefix, hashed_account_id_suffix]

    exec.memory::get_account_id movdn.3 movdn.3
    # => [hashed_account_id_prefix, hashed_account_id_suffix, account_id_prefix, account_id_suffix]

    # shape suffix of hashed id by setting the lower 8 bits to zero
    swap exec.account_id::shape_suffix swap
    # => [hashed_account_id_prefix, hashed_account_id_suffix, account_id_prefix, account_id_suffix]

    # assert the account ID matches the account ID of the new account
    exec.account_id::is_equal assert.err=ERR_ACCOUNT_SEED_AND_COMMITMENT_DIGEST_MISMATCH
    # => []
end

# ACCOUNT VAULT
# =================================================================================================

#! Adds the specified asset to the account vault.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET']
#!
#! Where:
#! - ASSET is the asset that is added to the vault.
#! - ASSET' final asset in the account vault defined as follows:
#!   - If ASSET is a non-fungible asset, then ASSET' is the same as ASSET.
#!   - If ASSET is a fungible asset, then ASSET' is the total fungible asset in the account vault
#!     after ASSET was added to it.
#!
#! Panics if:
#! - the asset is not valid.
#! - the total value of the fungible asset is greater than or equal to 2^63 after the new asset was
#!   added.
#! - the vault already contains the same non-fungible asset.
export.add_asset_to_vault
    # duplicate the ASSET to be able to emit an event after an asset is being added
    dupw
    # => [ASSET, ASSET]

    # fetch the account vault root
    exec.memory::get_account_vault_root_ptr movdn.4
    # => [ASSET, acct_vault_root_ptr, ASSET]

    # emit event to signal that an asset is going to be added to the account vault
    emit.ACCOUNT_VAULT_BEFORE_ADD_ASSET_EVENT

    # add the asset to the account vault
    exec.asset_vault::add_asset
    # => [ASSET', ASSET]

    swapw
    # => [ASSET, ASSET']

    dupw exec.account_delta::add_asset
    # => [ASSET, ASSET']

    # emit event to signal that an asset is being added to the account vault
    emit.ACCOUNT_VAULT_AFTER_ADD_ASSET_EVENT
    dropw
    # => [ASSET']
end

#! Removes the specified asset from the account vault.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - ASSET is the asset to remove from the vault.
#!
#! Panics if:
#! - the fungible asset is not found in the vault.
#! - the amount of the fungible asset in the vault is less than the amount to be removed.
#! - the non-fungible asset is not found in the vault.
export.remove_asset_from_vault
    # fetch the vault root
    exec.memory::get_account_vault_root_ptr movdn.4
    # => [ASSET, acct_vault_root_ptr]

    # emit event to signal that an asset is going to be removed from the account vault
    emit.ACCOUNT_VAULT_BEFORE_REMOVE_ASSET_EVENT

    # remove the asset from the account vault
    exec.asset_vault::remove_asset
    # => [ASSET]

    dupw exec.account_delta::remove_asset
    # => [ASSET]

    # emit event to signal that an asset is being removed from the account vault
    emit.ACCOUNT_VAULT_AFTER_REMOVE_ASSET_EVENT
    # => [ASSET]
end

#! Returns the balance of the fungible asset associated with the provided faucet_id in the current
#! account's vault.
#!
#! Inputs:  [faucet_id_prefix, faucet_id_suffix]
#! Outputs: [balance]
#!
#! Where:
#! - faucet_id_{prefix, suffix} are the prefix and suffix felts of the faucet id of the fungible
#!   asset of interest.
#! - balance is the vault balance of the fungible asset.
#!
#! Panics if:
#! - the provided faucet ID is not an ID of a fungible faucet.
export.get_balance
    # get the vault root
    exec.memory::get_account_vault_root_ptr movdn.2
    # => [faucet_id_prefix, faucet_id_suffix, vault_root_ptr]

    # emit event to signal that an asset's balance is requested
    emit.ACCOUNT_VAULT_BEFORE_GET_BALANCE_EVENT
    # => [faucet_id_prefix, faucet_id_suffix, vault_root_ptr]

    # get the asset balance
    exec.asset_vault::get_balance
    # => [balance]
end

#! Returns the balance of the fungible asset associated with the provided faucet_id in the current 
#! account's vault at the beginning of the transaction.
#!
#! Inputs:  [faucet_id_prefix, faucet_id_suffix]
#! Outputs: [init_balance]
#!
#! Where:
#! - faucet_id_{prefix, suffix} are the prefix and suffix felts of the faucet id of the fungible
#!   asset of interest.
#! - init_balance is the vault balance of the fungible asset at the beginning of the transaction.
#!
#! Panics if:
#! - the provided faucet ID is not an ID of a fungible faucet.
export.get_initial_balance
    # get the vault root associated with the initial vault root of the native account
    exec.memory::get_account_initial_vault_root_ptr movdn.2
    # => [faucet_id_prefix, faucet_id_suffix, init_native_vault_root_ptr]

    # emit event to signal that an asset's balance is requested
    emit.ACCOUNT_VAULT_BEFORE_GET_BALANCE_EVENT
    # => [faucet_id_prefix, faucet_id_suffix, init_native_vault_root_ptr]

    # get the asset balance
    exec.asset_vault::get_balance
    # => [init_balance]
end

#! Returns a boolean indicating whether the non-fungible asset is present in the current account's vault.
#!
#! Inputs:  [ASSET]
#! Outputs: [has_asset]
#!
#! Where:
#! - ASSET is the non-fungible asset of interest.
#! - has_asset is a boolean indicating whether the account vault has the asset of interest.
#!
#! Panics if:
#! - the ASSET is a fungible asset.
export.has_non_fungible_asset
    # get the vault root
    exec.memory::get_account_vault_root_ptr movdn.4
    # => [ASSET, vault_root_ptr]

    # emit event to signal that an asset's presence is being checked
    emit.ACCOUNT_VAULT_BEFORE_HAS_NON_FUNGIBLE_ASSET_EVENT
    # => [ASSET, vault_root_ptr]

    # check if the account vault has the non-fungible asset
    exec.asset_vault::has_non_fungible_asset
    # => [has_asset]
end


# DATA LOADERS
# =================================================================================================

#! Loads account data from the advice inputs into the _current_ account's memory section.
#!
#! Inputs:
#!   Operand stack: [account_id_prefix, account_id_suffix]
#!   Advice map: {
#!     ACCOUNT_ID: [[account_id_suffix, account_id_prefix, 0, account_nonce]],
#!                   VAULT_ROOT, STORAGE_COMMITMENT, CODE_COMMITMENT],
#!     STORAGE_COMMITMENT: [[STORAGE_SLOT_DATA]],
#!     CODE_COMMITMENT: [[ACCOUNT_PROCEDURE_DATA]],
#!   }
#! Outputs:
#!   Operand stack: []
#!
#! Where:
#! - account_id_{prefix,suffix} are the prefix and suffix felts of the ID of the account.
#! - ACCOUNT_ID is the word constructed from the account_id as follows:
#!   [account_id_suffix, account_id_prefix, 0, 0].
#! - account_nonce is the nonce of the account.
#! - VAULT_ROOT is the commitment of the account's vault.
#! - STORAGE_COMMITMENT is the commitment to the account's storage.
#! - STORAGE_SLOT_DATA is the data contained in the storage slot which is constructed as follows:
#!   [SLOT_VALUE, slot_type, 0, 0, 0].
#! - CODE_COMMITMENT is the commitment to the account's code.
#! - ACCOUNT_PROCEDURE_DATA is the information about account procedures which is constructed as
#!   follows: [PROCEDURE_MAST_ROOT, storage_offset, 0, 0, 0].
#!
#! Panics if:
#! - the number of account procedures exceeded the maximum limit of 256.
#! - the computed account code commitment does not match the provided account code commitment.
#! - the number of account storage slots exceeded the maximum limit of 255.
#! - the computed account storage commitment does not match the provided account storage commitment.
export.load_foreign_account
    emit.ACCOUNT_BEFORE_FOREIGN_LOAD_EVENT
    # => [account_id_prefix, account_id_suffix]

    # construct the word with account ID to load the core account data from the advice map
    push.0.0
    # OS => [0, 0, account_id_prefix, account_id_suffix]

    # move the core account data to the advice stack
    adv.push_mapval
    # OS => [0, 0, account_id_prefix, account_id_suffix]
    # AS => [[account_id_prefix, account_id_suffix, 0, account_nonce], VAULT_ROOT, STORAGE_COMMITMENT, CODE_COMMITMENT]

    # store the id and nonce of the foreign account to the memory
    adv_loadw
    exec.memory::set_account_id_and_nonce
    # OS => []
    # AS => [VAULT_ROOT, STORAGE_COMMITMENT, CODE_COMMITMENT]

    # store the vault root of the foreign account to the memory
    adv_loadw exec.memory::set_account_vault_root
    # OS => []
    # AS => [STORAGE_COMMITMENT, CODE_COMMITMENT]

    # move the storage root and the code root to the operand stack
    adv_loadw padw adv_loadw
    # OS => [CODE_COMMITMENT, STORAGE_COMMITMENT]
    # AS => []

    # store the code root into the memory
    exec.memory::set_account_code_commitment
    # OS => [CODE_COMMITMENT, STORAGE_COMMITMENT]
    # AS => []

    # save the account procedure data into the memory
    exec.save_account_procedure_data
    # OS => [STORAGE_COMMITMENT]
    # AS => []

    # store the storage root to the memory
    exec.memory::set_account_storage_commitment
    # OS => [STORAGE_COMMITMENT]
    # AS => []

    # save the storage slots data into the memory
    exec.save_account_storage_data
    # OS => []
    # AS => []
end

#! Saves storage slots data into memory and validates that the storage commitment matches the
#! sequential storage hash.
#!
#! Inputs:
#!   Operand stack: [STORAGE_COMMITMENT]
#!   Advice map: {
#!     STORAGE_COMMITMENT: [[STORAGE_SLOT_DATA]],
#!   }
#! Outputs:
#!   Operand stack: []
#!
#! Where:
#! - STORAGE_COMMITMENT is the commitment of the current account's storage.
#! - STORAGE_SLOT_DATA is the data contained in the storage slot which is constructed as follows:
#!   [SLOT_VALUE, slot_type, 0, 0, 0]
#!
#! Panics if:
#! - the number of account storage slots exceeded the maximum limit of 255.
#! - the computed account storage commitment does not match the provided account storage commitment.
export.save_account_storage_data
    # move storage slot data from the advice map to the advice stack
    adv.push_mapvaln
    # OS => [STORAGE_COMMITMENT]
    # AS => [storage_slot_data_len, [STORAGE_SLOT_DATA]]

    # push the length of the storage slot data onto the operand stack and compute the number of
    # storage slots from it
    adv_push.1 div.ACCOUNT_STORAGE_SLOT_DATA_LENGTH
    # OS => [num_storage_slots, STORAGE_COMMITMENT]
    # AS => [[STORAGE_SLOT_DATA]]

    # assert that account does not exceed allowed maximum number of storage slots
    dup exec.get_max_num_storage_slots lte assert.err=ERR_ACCOUNT_TOO_MANY_STORAGE_SLOTS
    # OS => [num_storage_slots, STORAGE_COMMITMENT]
    # AS => [[STORAGE_SLOT_DATA]]

    # store number of storage slots in memory
    dup exec.memory::set_num_storage_slots
    # OS => [num_storage_slots, STORAGE_COMMITMENT]
    # AS => [[STORAGE_SLOT_DATA]]

    # setup acct_storage_slots_ptr and end_ptr for reading from advice stack
    mul.8 exec.memory::get_account_storage_slots_section_ptr dup movdn.2 add swap
    # OS => [acct_storage_slots_ptr, end_ptr, STORAGE_COMMITMENT]
    # AS => [[STORAGE_SLOT_DATA]]

    # pad stack before reading from advice stack
    padw padw padw
    # OS => [PAD, PAD, PAD, acct_proc_offset, end_ptr, STORAGE_COMMITMENT]
    # AS => [[STORAGE_SLOT_DATA]]

    # read the data from advice stack to memory and hash
    exec.mem::pipe_double_words_to_memory
    # OS => [PERM, PERM, PERM, end_ptr', STORAGE_COMMITMENT]
    # AS => []

    # extract the digest
    exec.rpo::squeeze_digest
    # OS => [DIGEST, end_ptr', STORAGE_COMMITMENT]

    # drop end_ptr
    movup.4 drop
    # OS => [DIGEST, STORAGE_COMMITMENT]

    # verify hashed account storage slots match account storage commitment
    assert_eqw.err=ERR_ACCOUNT_STORAGE_COMMITMENT_MISMATCH
    # OS => []

    # duplicate the initial storage slots in memory to enable a diff computation
    # for the account delta
    exec.memory::mem_copy_initial_storage_slots
    # OS => []
end

#! Saves account procedure data into memory and validates that the code commitment matches the
#! sequential procedure root.
#!
#! Inputs:
#!   Operand stack: [CODE_COMMITMENT]
#!   Advice map: {
#!     CODE_COMMITMENT: [[ACCOUNT_PROCEDURE_DATA]],
#!   }
#! Outputs:
#!   Operand stack: []
#!
#! Where:
#! - CODE_COMMITMENT is the commitment of the current account's code.
#! - ACCOUNT_PROCEDURE_DATA is the information about account procedure which is constructed as
#!   follows: [PROCEDURE_MAST_ROOT, storage_offset, storage_size, 0, 0]
#!
#! Panics if:
#! - the number of account procedures exceeded the maximum limit of 256.
#! - the computed account code commitment does not match the provided account code commitment.
export.save_account_procedure_data
    # move procedure data from the advice map to the advice stack
    adv.push_mapvaln
    # OS => [CODE_COMMITMENT]
    # AS => [account_procedure_data_len, [ACCOUNT_PROCEDURE_DATA]]

    # push the length of the account procedure data onto the operand stack and compute the number of
    # procedures from it
    adv_push.1 div.ACCOUNT_PROCEDURE_DATA_LENGTH
    # OS => [num_procs, CODE_COMMITMENT]
    # AS => [[ACCOUNT_PROCEDURE_DATA]]

    # assert that account does not exceed allowed maximum number of procedures
    dup exec.get_max_num_procedures lte assert.err=ERR_ACCOUNT_TOO_MANY_PROCEDURES
    # OS => [num_procs, CODE_COMMITMENT]
    # AS => [[ACCOUNT_PROCEDURE_DATA]]

    # store number of procedures in memory
    dup exec.memory::set_num_account_procedures
    # OS => [num_procs, CODE_COMMITMENT]
    # AS => [[ACCOUNT_PROCEDURE_DATA]]

    # setup acct_proc_offset and end_ptr for reading from advice stack
    exec.memory::get_account_procedure_ptr
    push.0 exec.memory::get_account_procedure_ptr
    # OS => [acct_proc_offset, end_ptr, CODE_COMMITMENT]
    # AS => [[ACCOUNT_PROCEDURE_DATA]]

    # pad stack before reading from advice stack
    padw padw padw
    # OS => [PAD, PAD, PAD, acct_proc_offset, end_ptr, CODE_COMMITMENT]
    # AS => [[ACCOUNT_PROCEDURE_DATA]]

    # read the data from advice stack to memory and hash
    exec.mem::pipe_double_words_to_memory
    # OS => [PERM, PERM, PERM, end_ptr', CODE_COMMITMENT]
    # AS => []

    # extract the digest
    exec.rpo::squeeze_digest
    # OS => [DIGEST, end_ptr', CODE_COMMITMENT]

    # drop end_ptr
    movup.4 drop
    # OS => [DIGEST, CODE_COMMITMENT]

    # verify hashed account procedures match account code commitment
    assert_eqw.err=ERR_ACCOUNT_CODE_COMMITMENT_MISMATCH
    # OS => []
end

# HELPER PROCEDURES
# =================================================================================================

#! Gets an item from storage using the provided storage slots pointer and index.
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Inputs:  [storage_slots_ptr, index]
#! Outputs: [VALUE]
#!
#! Where:
#! - storage_slots_ptr is the pointer to the storage slots section.
#! - index is the index of the item to get.
#! - VALUE is the value of the item.
export.get_item_raw
    # get the item from storage
    swap mul.8 add padw movup.4 mem_loadw
    # => [VALUE]
end

#! Shared procedure for getting a map item from a storage slot.
#!
#! Inputs:  [KEY, ROOT, index]
#! Outputs: [VALUE]
#!
#! Where:
#! - KEY is the key to look up in the map.
#! - ROOT is the root of the map.
#! - index is the index of the storage slot that contains the map root.
#! - VALUE is the value of the map item at KEY.
#!
#! Panics if:
#! - the requested storage slot type is not map.
proc.get_map_item_raw
    # check storage slot type
    dup.8 exec.get_storage_slot_type
    # => [slot_type, KEY, ROOT, index]

    # check if storage slot type is map
    exec.constants::get_storage_slot_type_map eq
    assert.err=ERR_ACCOUNT_READING_MAP_VALUE_FROM_NON_MAP_SLOT
    # => [KEY, ROOT, index]

    emit.ACCOUNT_STORAGE_BEFORE_GET_MAP_ITEM_EVENT
    # => [KEY, ROOT, index]

    # see hash_map_key's docs for why this is done
    exec.hash_map_key
    # => [HASHED_KEY, ROOT, index]

    # fetch the VALUE located under HASHED_KEY in the tree
    exec.smt::get
    # => [VALUE, ROOT, index]

    # remove the ROOT from the stack
    swapw dropw
    # => [VALUE, index]

    movup.4 drop
    # => [VALUE]
end

#! Sets an item in the account storage. Doesn't emit any events.
#!
#! Inputs:  [index, NEW_VALUE]
#! Outputs: [OLD_VALUE]
#!
#! Where:
#! - index is the index of the item to set.
#! - NEW_VALUE is the value to set.
#! - OLD_VALUE is the previous value of the item.
proc.set_item_raw
    # get old value from storage
    dup movdn.5 exec.get_item
    # => [OLD_VALUE, NEW_VALUE, index]

    # arrange stack for storage update
    swapw movup.8
    # => [index, NEW_VALUE, OLD_VALUE]

    # get account storage slots section offset
    exec.memory::get_account_storage_slots_section_ptr
    # => [acct_storage_slots_section_offset, index, NEW_VALUE, OLD_VALUE]

    # update storage
    swap mul.8 add mem_storew
    # => [NEW_VALUE, OLD_VALUE]

    # update the storage commitment dirty flag, indicating that the commitment is outdated
    push.1
    exec.memory::set_native_account_storage_commitment_dirty_flag
    # => [NEW_VALUE, OLD_VALUE]

    # drop value
    dropw
    # => [OLD_VALUE]
end

#! Returns the procedure root.
#!
#! Inputs:  [index]
#! Outputs: [PROC_ROOT]
#!
#! Where:
#! - PROC_ROOT is the hash of the procedure.
#!
#! Panics if:
#! - the procedure index is out of bounds.
proc.get_procedure_root
    dup exec.memory::get_num_account_procedures
    u32assert2.err=ERR_ACCOUNT_PROC_INDEX_OUT_OF_BOUNDS u32lt assert.err=ERR_ACCOUNT_PROC_INDEX_OUT_OF_BOUNDS
    # => [index]

    # get procedure pointer
    exec.memory::get_account_procedure_ptr
    # => [proc_ptr]

    # load procedure root from memory
    padw movup.4 mem_loadw
    # => [PROC_ROOT]
end

#! Returns the procedure metadata.
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Inputs:  [index]
#! Outputs: [storage_offset, storage_size]
#!
#! Where:
#! - storage_offset is the procedure storage offset.
#! - storage_size is the number of storage slots the procedure is allowed to access.
proc.get_procedure_metadata
    # get procedure storage metadata pointer
    padw exec.memory::get_account_procedure_ptr add.4
    # => [storage_offset_ptr, EMPTY_WORD]

    # load procedure metadata from memory and keep relevant data
    mem_loadw drop drop swap
    # => [storage_offset, storage_size]
end

#! Returns the pointer to the next vacant memory slot if the account was not loaded before, and the
#! pointer to the account data otherwise.
#!
#! Inputs:  [foreign_account_id_prefix, foreign_account_id_suffix]
#! Outputs: [was_loaded, ptr, foreign_account_id_prefix, foreign_account_id_suffix]
#!
#! Where:
#! - foreign_account_id_{prefix,suffix} are the prefix and suffix felts of the ID of the foreign
#!   account whose procedure is going to be executed.
#! - was_loaded is the binary flag indicating whether the foreign account was already loaded to the
#!   memory.
#! - ptr is the memory pointer to the next empty memory slot or the memory pointer to the account
#!   data, depending on the value of the was_loaded flag.
#!
#! Panics if:
#! - the prefix or suffix of the provided foreign account ID equal zero.
#! - the maximum allowed number of foreign account to be loaded (64) was exceeded.
export.get_account_data_ptr
    # check that foreign account ID is not equal zero
    dup.1 eq.0 dup.1 eq.0 and not assert.err=ERR_FOREIGN_ACCOUNT_ID_IS_ZERO
    # => [foreign_account_id_prefix, foreign_account_id_suffix]

    # move pointer one account block back so that the first account pointer in the cycle will point
    # to the native account
    exec.memory::get_native_account_data_ptr exec.memory::get_account_data_length sub
    # => [curr_account_ptr, foreign_account_id_prefix, foreign_account_id_suffix]

    # push the flag to enter the loop
    push.1

    while.true
        # drop the flag left from the previous loop
        # in the first iteration this will be a pad element
        movup.3 drop
        # => [curr_account_ptr, foreign_account_id_prefix, foreign_account_id_suffix]

        # move the current account pointer to the next account data block
        exec.memory::get_account_data_length add
        # => [curr_account_ptr', foreign_account_id_prefix, foreign_account_id_suffix]

        # load the first data word at the current account pointer
        padw dup.4 mem_loadw
        # => [FIRST_DATA_WORD, curr_account_ptr', foreign_account_id_prefix, foreign_account_id_suffix]

        # check whether the last value in the word equals zero
        # if so it means this memory block was not yet initialized
        drop drop dup.1 eq.0
        # => [is_empty_block, maybe_account_id_prefix, maybe_account_id_suffix, curr_account_ptr', foreign_account_id_prefix, foreign_account_id_suffix]

        # check whether the current id matches the foreign id
        movdn.2 dup.5 dup.5 exec.account_id::is_equal
        # => [is_equal_id, is_empty_word, curr_account_ptr', foreign_account_id_prefix, foreign_account_id_suffix]

        # get the loop flag
        # it equals 1 if both `is_equal_id` and `is_empty_block` flags are equal to 0, so we should
        # continue iterating
        dup movdn.5 or not
        # => [loop_flag, curr_account_ptr', foreign_account_id_prefix, foreign_account_id_suffix, is_equal_id]
    end

    # check that the loading of one more account won't exceed the maximum number of the foreign
    # accounts which can be loaded.
    dup exec.memory::get_max_foreign_account_ptr lte
    assert.err=ERR_FOREIGN_ACCOUNT_MAX_NUMBER_EXCEEDED
    # => [curr_account_ptr, foreign_account_id_prefix, foreign_account_id_suffix, is_equal_id]

    # the resulting `was_loaded` flag is essentially equal to the `is_equal_id` flag
    movup.3
    # => [was_loaded, curr_account_ptr, foreign_account_id_prefix, foreign_account_id_suffix]
end

#! Checks that the state of the current foreign account is valid.
#!
#! Inputs:  []
#! Outputs: []
#!
#! Panics if:
#! - the hash of the current account is not represented in the account database.
export.validate_current_foreign_account
    # get the account database root
    exec.memory::get_account_db_root
    # => [ACCOUNT_DB_ROOT]

    # get the current account ID
    push.0.0 exec.memory::get_account_id
    # => [account_id_prefix, account_id_suffix, 0, 0, ACCOUNT_DB_ROOT]

    # retrieve the commitment of the foreign account from the current account tree
    # this would abort if the proof for the commitment was invalid for the account root,
    # so this implicitly verifies its correctness
    exec.smt::get
    # => [FOREIGN_ACCOUNT_COMMITMENT, ACCOUNT_DB_ROOT]

    # get the foreign account's commitment from memory and compare with the verified commitment
    exec.compute_current_commitment assert_eqw.err=ERR_FOREIGN_ACCOUNT_INVALID_COMMITMENT
    # => [ACCOUNT_DB_ROOT]

    # clean the stack
    dropw
end

#! Hashes the provided map key before using it as the key in an SMT.
#!
#! Because the keys of the map are user-chosen and thus not necessarily uniformly distributed, the
#! tree could be imbalanced and made less efficient. To mitigate that, the keys used in the
#! storage map are hashed before they are inserted into the SMT, which creates a uniform distribution.
#!
#! Inputs:  [KEY]
#! Outputs: [HASHED_KEY]
proc.hash_map_key
    hash
    # => [HASHED_KEY]
end

#! Makes the account storage commitment up-to-date.
#!
#! Notice that the account storage commitment got updated only if it is outdated: if the account
#! storage changes, its commitment will be recomputed by hashing the storage slots. Then this newly
#! computed storage commitment updates the storage commitment in memory. If the storage commitment
#! is up-to-date, this procedure does nothing.
#!
#! Inputs:  []
#! Outputs: []
proc.refresh_storage_commitment
    # First we should determine whether the storage commitment should be recomputed. We should do so
    # if the current account is native and the storage commitment is outdated (the dirty flag equals
    # 1). Otherwise the commitment value is guaranteed to be up-to-date.
    exec.memory::get_recompute_storage_commitment_flag
    # => [should_recompute_storage_commitment]

    if.true
        # dirty flag being equal 1 ensures that we have at least one storage slot, so we have to
        # hash the storage anyway

        # get number of storage slots
        exec.memory::get_num_storage_slots
        # => [num_storage_slots]

        # setup start and end ptr
        mul.8 exec.memory::get_account_storage_slots_section_ptr dup movdn.2 add swap
        # => [start_ptr, end_ptr]

        # pad stack to read and hash from memory
        padw padw padw
        # => [PAD, PAD, PAD, start_ptr, end_ptr]

        # hash elements from memory
        exec.rpo::absorb_double_words_from_memory
        # => [PERM, PERM, PERM, start_ptr, end_ptr]

        # extract the digest
        exec.rpo::squeeze_digest
        # => [DIGEST, end_ptr, end_ptr]

        # clean stack
        movup.4 drop movup.4 drop
        # => [DIGEST]

        # set new account storage commitment
        exec.memory::set_account_storage_commitment dropw
        # => []

        # update the storage commitment dirty flag, indicating that the commitment is up-to-date
        push.0
        exec.memory::set_native_account_storage_commitment_dirty_flag
        # => []
    end
end

#! Checks if a procedure has been called during transaction execution.
#!
#! Note: This returns 1 only if the procedure invoked account-restricted kernel APIs (e.g.,
#! `exec.faucet::mint`) which trigger `authenticate_and_track_procedure`. Procedures that execute
#! only local MASM instructions will return 0 even if they were executed.
#!
#! Inputs:  [PROC_ROOT]
#! Outputs: [was_called]
#!
#! Where:
#! - PROC_ROOT is the hash of the procedure to check.
#! - was_called is 1 if the procedure was called, 0 otherwise.
#!
#! Panics if:
#! - the procedure root is not part of the account code.
export.was_procedure_called
    # load procedure index
    emit.ACCOUNT_PUSH_PROCEDURE_INDEX_EVENT adv_push.1
    # => [index, PROC_ROOT]

    dup movdn.5
    # => [index, PROC_ROOT, index]

    # get procedure root from memory stored at index
    exec.get_procedure_root
    # => [MEM_PROC_ROOT, PROC_ROOT, index]

    # verify that PROC_ROOT exists in memory at index
    assert_eqw.err=ERR_ACCOUNT_PROC_NOT_PART_OF_ACCOUNT_CODE
    # => [index]

    exec.memory::get_account_procedures_call_tracking_ptr
    # => [was_called_offset, index]

    # load the value of was_called
    add mem_load
    # => [was_called]
end

#! Sets the was_called flag to 1 for the specified procedure.
#!
#! Note:
#! - This is an internal procedure. Unlike `was_procedure_called`, it expects the stack to contain
#!   the index, not the procedure root.
#! - We assume the index has been validated and is within bounds.
#!
#! Inputs:  [proc_idx]
#! Outputs: []
export.set_was_procedure_called
    exec.memory::get_account_procedures_call_tracking_ptr
    # => [was_called_offset, proc_idx]

    # save 1 to the was_called address
    add push.1 swap mem_store
end
